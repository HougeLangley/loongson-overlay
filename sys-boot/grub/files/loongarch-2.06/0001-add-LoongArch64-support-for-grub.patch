From ae9c32040e9b4550672cc858accb732456fb6fb5 Mon Sep 17 00:00:00 2001
From: zeiwai <zylinux94@gmail.com>
Date: Thu, 27 May 2021 16:13:22 +0800
Subject: [PATCH 1/6] add LoongArch64 support for grub

---
 conf/Makefile.common                          |   4 +
 configure.ac                                  |   9 +
 gentpl.py                                     |   5 +-
 grub-core/Makefile.am                         |   7 +
 grub-core/Makefile.core.def                   |  18 +
 grub-core/kern/loongarch64/cache.S            |  25 +
 grub-core/kern/loongarch64/dl.c               | 260 +++++++++
 grub-core/kern/loongarch64/efi/init.c         |  75 +++
 grub-core/kern/loongarch64/efi/startup.S      |  40 ++
 grub-core/lib/gnulib-patches/loongarch.patch  |  26 +
 grub-core/lib/loongarch64/efi/loongarch64.c   | 505 ++++++++++++++++
 .../lib/loongarch64/efi/loongarch64_asm.S     |  58 ++
 grub-core/lib/loongarch64/relocator.c         | 160 +++++
 grub-core/lib/loongarch64/relocator_asm.S     |  50 ++
 grub-core/lib/loongarch64/setjmp.S            |  64 ++
 grub-core/lib/setjmp.S                        |   2 +
 grub-core/loader/loongarch64/linux.c          | 551 ++++++++++++++++++
 include/grub/dl.h                             |   3 +-
 include/grub/efi/api.h                        |   2 +-
 include/grub/efi/pe32.h                       |   2 +
 include/grub/elf.h                            |  23 +
 include/grub/loongarch64/asm.h                |  28 +
 include/grub/loongarch64/efi/loader.h         |  25 +
 include/grub/loongarch64/efi/loongarch64.h    | 290 +++++++++
 include/grub/loongarch64/efi/memory.h         |  32 +
 include/grub/loongarch64/io.h                 |  61 ++
 include/grub/loongarch64/kernel.h             |  24 +
 include/grub/loongarch64/loongarch64.h        |  28 +
 include/grub/loongarch64/memory.h             |  54 ++
 include/grub/loongarch64/relocator.h          |  36 ++
 include/grub/loongarch64/setjmp.h             |  27 +
 include/grub/loongarch64/time.h               |  36 ++
 include/grub/loongarch64/types.h              |  29 +
 include/grub/util/install.h                   |   1 +
 util/grub-install-common.c                    |   1 +
 util/grub-install.c                           |  16 +
 util/grub-mkimagexx.c                         | 255 +++++++-
 util/grub-module-verifier.c                   |  26 +
 util/mkimage.c                                |  16 +
 39 files changed, 2862 insertions(+), 12 deletions(-)
 create mode 100644 grub-core/kern/loongarch64/cache.S
 create mode 100644 grub-core/kern/loongarch64/dl.c
 create mode 100644 grub-core/kern/loongarch64/efi/init.c
 create mode 100644 grub-core/kern/loongarch64/efi/startup.S
 create mode 100644 grub-core/lib/gnulib-patches/loongarch.patch
 create mode 100644 grub-core/lib/loongarch64/efi/loongarch64.c
 create mode 100644 grub-core/lib/loongarch64/efi/loongarch64_asm.S
 create mode 100644 grub-core/lib/loongarch64/relocator.c
 create mode 100644 grub-core/lib/loongarch64/relocator_asm.S
 create mode 100644 grub-core/lib/loongarch64/setjmp.S
 create mode 100644 grub-core/loader/loongarch64/linux.c
 create mode 100644 include/grub/loongarch64/asm.h
 create mode 100644 include/grub/loongarch64/efi/loader.h
 create mode 100644 include/grub/loongarch64/efi/loongarch64.h
 create mode 100644 include/grub/loongarch64/efi/memory.h
 create mode 100644 include/grub/loongarch64/io.h
 create mode 100644 include/grub/loongarch64/kernel.h
 create mode 100644 include/grub/loongarch64/loongarch64.h
 create mode 100644 include/grub/loongarch64/memory.h
 create mode 100644 include/grub/loongarch64/relocator.h
 create mode 100644 include/grub/loongarch64/setjmp.h
 create mode 100644 include/grub/loongarch64/time.h
 create mode 100644 include/grub/loongarch64/types.h

diff --git a/conf/Makefile.common b/conf/Makefile.common
index 2a1a886f6..bcbf95156 100644
--- a/conf/Makefile.common
+++ b/conf/Makefile.common
@@ -20,6 +20,10 @@ endif
 if COND_powerpc_ieee1275
   CFLAGS_PLATFORM += -mcpu=powerpc
 endif
+if COND_loongarch64
+  CFLAGS_PLATFORM += -fno-strict-aliasing -march=loongarch -mabi=lp64 -fno-plt -Wa,-mla-global-with-pcrel
+  CPPFLAGS_PLATFORM = -fno-strict-aliasing -march=loongarch -mabi=lp64 -fno-plt -Wa,-mla-global-with-pcrel
+endif
 
 # Other options
 
diff --git a/configure.ac b/configure.ac
index 7517fc49d..c6d351a4a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -99,6 +99,10 @@ case "$target_cpu" in
   i[[3456]]86)	target_cpu=i386 ;;
   amd64)	target_cpu=x86_64 ;;
   sparc)	target_cpu=sparc64 ;;
+  loongarch64)
+                target_cpu=loongarch64
+		machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_CPU_LOONGARCH64=1"
+		;;
   mipsel|mips64el)
                 target_cpu=mipsel
 		machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_CPU_MIPSEL=1"
@@ -137,6 +141,7 @@ if test "x$with_platform" = x; then
     powerpc64-*) platform=ieee1275 ;;
     powerpc64le-*) platform=ieee1275 ;;
     sparc64-*) platform=ieee1275 ;;
+    loongarch64-*) platform=efi;;
     mipsel-*) platform=loongson ;;
     mips-*) platform=arc ;;
     ia64-*) platform=efi ;;
@@ -188,6 +193,7 @@ case "$target_cpu"-"$platform" in
   mipsel-yeeloong) platform=loongson ;;
   mipsel-fuloong) platform=loongson ;;
   mipsel-loongson) ;;
+  loongarch64-efi) ;;
   arm-uboot) ;;
   arm-coreboot) ;;
   arm-efi) ;;
@@ -246,6 +252,7 @@ case "$platform" in
   pc)		machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_PCBIOS=1" ;;
   emu)		machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_EMU=1" ;;
   loongson)	machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_MIPS_LOONGSON=1" ;;
+  loongarch64)	machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_LOONARCH64=1" ;;
   qemu_mips)	machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_MIPS_QEMU_MIPS=1" ;;
   arc)	machine_CPPFLAGS="$machine_CPPFLAGS -DGRUB_MACHINE_ARC=1" ;;
 esac
@@ -1986,6 +1993,8 @@ AM_CONDITIONAL([COND_mips_arc], [test "(" x$target_cpu = xmips -o x$target_cpu =
 AM_CONDITIONAL([COND_sparc64_ieee1275], [test x$target_cpu = xsparc64 -a x$platform = xieee1275])
 AM_CONDITIONAL([COND_sparc64_emu], [test x$target_cpu = xsparc64 -a x$platform = xemu])
 AM_CONDITIONAL([COND_powerpc_ieee1275], [test x$target_cpu = xpowerpc -a x$platform = xieee1275])
+AM_CONDITIONAL([COND_loongarch64_efi], [test x$target_cpu = xloongarch64 -a x$platform = xefi])
+AM_CONDITIONAL([COND_loongarch64], [test x$target_cpu = xloongarch64])
 AM_CONDITIONAL([COND_mips], [test x$target_cpu = xmips -o x$target_cpu = xmipsel])
 AM_CONDITIONAL([COND_mipsel], [test x$target_cpu = xmipsel])
 AM_CONDITIONAL([COND_mipseb], [test x$target_cpu = xmips])
diff --git a/gentpl.py b/gentpl.py
index c86550d4f..b00b4a2a0 100644
--- a/gentpl.py
+++ b/gentpl.py
@@ -32,7 +32,7 @@ GRUB_PLATFORMS = [ "emu", "i386_pc", "i386_efi", "i386_qemu", "i386_coreboot",
                    "mips_loongson", "sparc64_ieee1275",
                    "powerpc_ieee1275", "mips_arc", "ia64_efi",
                    "mips_qemu_mips", "arm_uboot", "arm_efi", "arm64_efi",
-                   "arm_coreboot", "riscv32_efi", "riscv64_efi" ]
+                   "arm_coreboot", "riscv32_efi", "riscv64_efi","loongarch64_efi" ]
 
 GROUPS = {}
 
@@ -49,10 +49,11 @@ GROUPS["arm"]      = [ "arm_uboot", "arm_efi", "arm_coreboot" ]
 GROUPS["arm64"]    = [ "arm64_efi" ]
 GROUPS["riscv32"]  = [ "riscv32_efi" ]
 GROUPS["riscv64"]  = [ "riscv64_efi" ]
+GROUPS["loongarch64"]   = [ "loongarch64_efi" ]
 
 # Groups based on firmware
 GROUPS["efi"]  = [ "i386_efi", "x86_64_efi", "ia64_efi", "arm_efi", "arm64_efi",
-		   "riscv32_efi", "riscv64_efi" ]
+		   "riscv32_efi", "riscv64_efi", "loongarch64_efi" ]
 GROUPS["ieee1275"]   = [ "i386_ieee1275", "sparc64_ieee1275", "powerpc_ieee1275" ]
 GROUPS["uboot"] = [ "arm_uboot" ]
 GROUPS["xen"]  = [ "i386_xen", "x86_64_xen" ]
diff --git a/grub-core/Makefile.am b/grub-core/Makefile.am
index ee88e44e9..61ee5f554 100644
--- a/grub-core/Makefile.am
+++ b/grub-core/Makefile.am
@@ -238,6 +238,13 @@ KERNEL_HEADER_FILES += $(top_builddir)/include/grub/machine/memory.h
 KERNEL_HEADER_FILES += $(top_builddir)/include/grub/machine/kernel.h
 endif
 
+if COND_loongarch64_efi
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/efi/efi.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/efi/disk.h
+KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/acpi.h
+KERNEL_HEADER_FILES += $(top_builddir)/include/grub/machine/loongarch64.h
+endif
+
 if COND_powerpc_ieee1275
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/ieee1275/ieee1275.h
 KERNEL_HEADER_FILES += $(top_srcdir)/include/grub/terminfo.h
diff --git a/grub-core/Makefile.core.def b/grub-core/Makefile.core.def
index 8022e1c0a..15a81be73 100644
--- a/grub-core/Makefile.core.def
+++ b/grub-core/Makefile.core.def
@@ -103,6 +103,9 @@ kernel = {
   arm_coreboot_ldflags       = '-Wl,-r,-d';
   arm_coreboot_stripflags    = '--strip-unneeded -K start -R .note -R .comment -R .note.gnu.gold-version';
 
+  loongarch64_efi_ldflags      = '-Wl,-r,-d';
+  loongarch64_efi_stripflags   = '--strip-unneeded -K start -R .eh_frame';
+
   i386_pc_startup = kern/i386/pc/startup.S;
   i386_efi_startup = kern/i386/efi/startup.S;
   x86_64_efi_startup = kern/x86_64/efi/startup.S;
@@ -114,6 +117,7 @@ kernel = {
   i386_coreboot_startup = kern/i386/coreboot/startup.S;
   i386_multiboot_startup = kern/i386/coreboot/startup.S;
   mips_startup = kern/mips/startup.S;
+  loongarch64_efi_startup = kern/loongarch64/efi/startup.S;
   sparc64_ieee1275_startup = kern/sparc64/ieee1275/crt0.S;
   powerpc_ieee1275_startup = kern/powerpc/ieee1275/startup.S;
   arm_uboot_startup = kern/arm/startup.S;
@@ -314,6 +318,13 @@ kernel = {
   extra_dist = video/sis315_init.c;
   mips_loongson = commands/keylayouts.c;
 
+  loongarch64 = kern/loongarch64/dl.c;
+  loongarch64 = kern/loongarch64/cache.S;
+
+  loongarch64_efi = kern/loongarch64/efi/init.c;
+  loongarch64_efi = lib/loongarch64/efi/loongarch64.c;
+  loongarch64_efi = lib/loongarch64/efi/loongarch64_asm.S;
+
   powerpc_ieee1275 = kern/powerpc/cache.S;
   powerpc_ieee1275 = kern/powerpc/dl.c;
   powerpc_ieee1275 = kern/powerpc/compiler-rt.S;
@@ -822,6 +833,7 @@ module = {
   enable = sparc64_ieee1275;
   enable = powerpc_ieee1275;
   enable = mips_arc;
+  enable = loongarch64_efi;
   enable = ia64_efi;
   enable = arm_efi;
   enable = arm64_efi;
@@ -912,6 +924,7 @@ module = {
   xen = lib/xen/halt.c;
   i386_xen_pvh = lib/xen/halt.c;
   efi = lib/efi/halt.c;
+  loongarch64_efi = commands/acpihalt.c;
   ieee1275 = lib/ieee1275/halt.c;
   emu = lib/emu/halt.c;
   uboot = lib/dummy/halt.c;
@@ -1660,6 +1673,8 @@ module = {
   efi = lib/efi/relocator.c;
   mips = lib/mips/relocator_asm.S;
   mips = lib/mips/relocator.c;
+  loongarch64 = lib/loongarch64/relocator_asm.S;
+  loongarch64 = lib/loongarch64/relocator.c;
   powerpc = lib/powerpc/relocator_asm.S;
   powerpc = lib/powerpc/relocator.c;
   xen = lib/xen/relocator.c;
@@ -1672,6 +1687,7 @@ module = {
   extra_dist = kern/powerpc/cache_flush.S;
 
   enable = mips;
+  enable = loongarch64;
   enable = powerpc;
   enable = x86;
   enable = i386_xen_pvh;
@@ -1802,6 +1818,7 @@ module = {
   i386_pc = lib/i386/pc/vesa_modes_table.c;
   i386_xen_pvh = lib/i386/pc/vesa_modes_table.c;
   mips = loader/mips/linux.c;
+  loongarch64 = loader/loongarch64/linux.c;
   powerpc_ieee1275 = loader/powerpc/ieee1275/linux.c;
   sparc64_ieee1275 = loader/sparc64/ieee1275/linux.c;
   ia64_efi = loader/ia64/efi/linux.c;
@@ -1908,6 +1925,7 @@ module = {
   enable = riscv32_efi;
   enable = riscv64_efi;
   enable = mips;
+  enable = loongarch64_efi;
 };
 
 module = {
diff --git a/grub-core/kern/loongarch64/cache.S b/grub-core/kern/loongarch64/cache.S
new file mode 100644
index 000000000..eb00f634a
--- /dev/null
+++ b/grub-core/kern/loongarch64/cache.S
@@ -0,0 +1,25 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+
+FUNCTION (grub_arch_sync_caches)
+	jirl $zero,$ra,0
+
+FUNCTION (grub_arch_sync_dma_caches)
+	jirl $zero,$ra,0
diff --git a/grub-core/kern/loongarch64/dl.c b/grub-core/kern/loongarch64/dl.c
new file mode 100644
index 000000000..096b1a529
--- /dev/null
+++ b/grub-core/kern/loongarch64/dl.c
@@ -0,0 +1,260 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/elf.h>
+#include <grub/misc.h>
+#include <grub/err.h>
+#include <grub/cpu/types.h>
+#include <grub/mm.h>
+#include <grub/i18n.h>
+
+#define RELOC_STACK_MAX 1024
+
+/* Check if EHDR is a valid ELF header.  */
+grub_err_t
+grub_arch_dl_check_header (void *ehdr)
+{
+  Elf_Ehdr *e = ehdr;
+
+  /* Check the magic numbers.  */
+  if (e->e_ident[EI_CLASS] != ELFCLASS64
+      || e->e_ident[EI_DATA] != ELFDATA2LSB
+      || e->e_machine != EM_LOONGARCH64)
+    return grub_error (GRUB_ERR_BAD_OS, N_("invalid arch-dependent ELF magic"));
+
+  return GRUB_ERR_NONE;
+}
+
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+grub_err_t
+grub_arch_dl_get_tramp_got_size (const void *ehdr __attribute__ ((unused)),
+				 grub_size_t *tramp, grub_size_t *got)
+{
+  *tramp = 0;
+  *got = 0;
+  return GRUB_ERR_NONE;
+}
+
+/* Relocate symbols.  */
+grub_err_t
+grub_arch_dl_relocate_symbols (grub_dl_t mod, void *ehdr,
+			       Elf_Shdr *s, grub_dl_segment_t seg)
+{
+  Elf_Ehdr *e = ehdr;
+  Elf_Rel *rel, *max;
+  grub_uint64_t oprs[RELOC_STACK_MAX]={0};
+  int opri=-1;
+  grub_uint32_t la_abs = 0;
+
+  for (rel = (Elf_Rel *) ((char *) e + s->sh_offset),
+	 max = (Elf_Rel *) ((char *) rel + s->sh_size);
+       rel < max;
+       rel = (Elf_Rel *) ((char *) rel + s->sh_entsize))
+    {
+      grub_uint8_t *addr;
+      Elf_Sym *sym;
+      Elf_Addr r_info;
+      grub_uint64_t sym_value;
+
+      if (seg->size < rel->r_offset)
+	return grub_error (GRUB_ERR_BAD_MODULE,
+			   "reloc offset is out of the segment");
+
+      r_info = (grub_uint64_t) (rel->r_info);
+      addr = (grub_uint8_t *) ((char*)seg->addr + rel->r_offset);
+      sym = (Elf_Sym *) ((char*)mod->symtab
+			 + mod->symsize * ELF_R_SYM (r_info));
+      sym_value = sym->st_value;
+      if (s->sh_type == SHT_RELA)
+	{
+	  sym_value += ((Elf_Rela *) rel)->r_addend;
+	}
+      switch (ELF_R_TYPE (r_info))
+	{
+	case R_LARCH_64:
+	  {
+	    *(grub_uint64_t *)addr=(grub_uint64_t)sym_value;
+	  }
+	break;
+	case R_LARCH_MARK_LA:
+	  {
+	    la_abs=1;
+	  }
+	break;
+	case R_LARCH_SOP_PUSH_PCREL:
+	  {
+	    opri++;
+	    oprs[opri]=(grub_uint64_t)(sym_value-(grub_uint64_t)addr);
+	  }
+	break;
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	  {
+	    opri++;
+	    oprs[opri]=(grub_uint64_t)sym_value;
+	  }
+	break;
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	  {
+	    opri++;
+	    oprs[opri]=(grub_uint64_t)(sym_value-(grub_uint64_t)addr);
+	  }
+	  break;
+	case R_LARCH_SOP_SUB:
+	  {
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    opri++;
+	    oprs[opri]=opr1 - opr2;
+	  }
+	  break;
+	case R_LARCH_SOP_SL:
+	  {
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    opri++;
+	    oprs[opri]=opr1 << opr2;
+	  }
+	  break;
+	case R_LARCH_SOP_SR:
+	  {
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    opri++;
+	    oprs[opri]=opr1 >> opr2;
+	  }
+	  break;
+	case R_LARCH_SOP_ADD:
+	  {
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    opri++;
+	    oprs[opri]=opr1 + opr2;
+	  }
+	  break;
+	case R_LARCH_SOP_AND:
+	  {
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    opri++;
+	    oprs[opri]=opr1 & opr2;
+	  }
+	  break;
+	case R_LARCH_SOP_IF_ELSE:
+	  {
+	    grub_uint64_t opr3=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr2=oprs[opri];
+	    opri--;
+	    grub_uint64_t opr1=oprs[opri];
+	    opri--;
+	    if(opr1)
+	      {
+	    	opri++;
+	    	oprs[opri]=opr2;
+	      } 
+	    else 
+	      {
+	    	opri++;
+	    	oprs[opri]=opr3;
+	      }
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_10_5:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | ((opr1 & 0x1f) << 10);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_U_10_12:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | ((opr1 & 0xfff) << 10);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_10_12:
+	  {
+	    if(la_abs==1)
+	      la_abs=0;
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr= (*(grub_uint64_t *)addr) | ((opr1 & 0xfff) << 10);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_10_16:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr= (*(grub_uint64_t *)addr) | ((opr1 & 0xffff) << 10);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_10_16_S2:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr= (*(grub_uint64_t *)addr) | (((opr1 >> 2) & 0xffff) << 10);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_5_20:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr= (*(grub_uint64_t *)addr) | ((opr1 & 0xfffff)<<5)	;
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | (((opr1 >> 2) & 0xffff) << 10);
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | ((opr1 >> 18) & 0x1f);
+	  }
+	  break;
+	case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+	  {
+	    grub_uint64_t opr1 = oprs[opri];
+	    opri--;
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | (((opr1 >> 2) & 0xffff) << 10);
+	    *(grub_uint64_t *)addr=(*(grub_uint64_t *)addr) | ((opr1 >> 18) & 0x3ff);
+	  }
+	  break;
+	default:
+	  {
+	    return grub_error (GRUB_ERR_NOT_IMPLEMENTED_YET,
+			       N_("relocation 0x%x is not implemented yet"),
+			       ELF_R_TYPE (r_info));
+	  }
+	  break;
+	}
+    }
+  return GRUB_ERR_NONE;
+}
+
diff --git a/grub-core/kern/loongarch64/efi/init.c b/grub-core/kern/loongarch64/efi/init.c
new file mode 100644
index 000000000..ca4322ff5
--- /dev/null
+++ b/grub-core/kern/loongarch64/efi/init.c
@@ -0,0 +1,75 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/env.h>
+#include <grub/kernel.h>
+#include <grub/misc.h>
+#include <grub/mm.h>
+#include <grub/cpu/time.h>
+#include <grub/efi/efi.h>
+#include <grub/loader.h>
+#include <grub/machine/loongarch64.h>
+
+static grub_uint64_t tmr;
+static grub_efi_event_t tmr_evt;
+
+static grub_uint64_t
+grub_efi_get_time_ms (void)
+{
+  return tmr;
+}
+
+static void
+grub_loongson_increment_timer (grub_efi_event_t event __attribute__ ((unused)),
+                 void *context __attribute__ ((unused)))
+{
+  tmr += 10;
+}
+
+
+
+void
+grub_machine_init (void)
+{
+  grub_efi_boot_services_t *b;
+
+  grub_efi_init ();
+  
+  b = grub_efi_system_table->boot_services;
+  efi_call_5 (b->create_event, GRUB_EFI_EVT_TIMER | GRUB_EFI_EVT_NOTIFY_SIGNAL,
+              GRUB_EFI_TPL_CALLBACK, grub_loongson_increment_timer, NULL, &tmr_evt);
+  efi_call_3 (b->set_timer, tmr_evt, GRUB_EFI_TIMER_PERIODIC, 100000);
+
+  grub_install_get_time_ms (grub_efi_get_time_ms);
+}
+
+void
+grub_machine_fini (int flags)
+{
+  grub_efi_boot_services_t *b;
+
+  if (!(flags & GRUB_LOADER_FLAG_NORETURN))
+    return;
+
+  b = grub_efi_system_table->boot_services;
+
+  efi_call_3 (b->set_timer, tmr_evt, GRUB_EFI_TIMER_CANCEL, 0);
+  efi_call_1 (b->close_event, tmr_evt);
+
+  grub_efi_fini ();
+}
diff --git a/grub-core/kern/loongarch64/efi/startup.S b/grub-core/kern/loongarch64/efi/startup.S
new file mode 100644
index 000000000..250ac0a5c
--- /dev/null
+++ b/grub-core/kern/loongarch64/efi/startup.S
@@ -0,0 +1,40 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+
+	.file 	"startup.S"
+	.text
+
+	.align		4
+
+FUNCTION(_start)
+	addi.d		$sp, $sp, -16
+	st.d		$ra, $sp, 0
+
+	la 		$a2, grub_efi_image_handle
+	st.d		$a0, $a2, 0
+	la		$a2, grub_efi_system_table
+	st.d		$a1, $a2, 0
+
+	bl		grub_main
+
+1:
+	ld.d		$ra, $sp, 0
+	addi.d		$sp, $sp, 16
+	jirl 		$zero, $ra, 0
diff --git a/grub-core/lib/gnulib-patches/loongarch.patch b/grub-core/lib/gnulib-patches/loongarch.patch
new file mode 100644
index 000000000..54cc2e084
--- /dev/null
+++ b/grub-core/lib/gnulib-patches/loongarch.patch
@@ -0,0 +1,26 @@
+diff --git a/build-aux/config.guess b/build-aux/config.guess
+index 8e2a58b86..5ebbfa1a7 100755
+--- a/build-aux/config.guess
++++ b/build-aux/config.guess
+@@ -990,6 +990,9 @@ EOF
+     k1om:Linux:*:*)
+ 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+ 	exit ;;
++    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
++	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
++	exit ;;
+     m32r*:Linux:*:*)
+ 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+ 	exit ;;
+diff --git a/build-aux/config.sub b/build-aux/config.sub
+index 1fc4cde1d..8d8b43e02 100755
+--- a/build-aux/config.sub
++++ b/build-aux/config.sub
+@@ -1184,6 +1184,7 @@ case $cpu-$vendor in
+ 			| k1om \
+ 			| le32 | le64 \
+ 			| lm32 \
++			| loongarch32 | loongarch64 \
+ 			| m32c | m32r | m32rle \
+ 			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k | v70 | w65 \
+ 			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip \
diff --git a/grub-core/lib/loongarch64/efi/loongarch64.c b/grub-core/lib/loongarch64/efi/loongarch64.c
new file mode 100644
index 000000000..e4bbf6998
--- /dev/null
+++ b/grub-core/lib/loongarch64/efi/loongarch64.c
@@ -0,0 +1,505 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2017 Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/mm.h>
+#include <grub/cache.h>
+#include <grub/efi/efi.h>
+#include <grub/cpu/efi/memory.h>
+#include <grub/cpu/memory.h>
+#include <grub/machine/loongarch64.h>
+
+#define loongson_params (&loongson_boot_params->boot_params.efi.smbios.lp)
+#define loongson_boot_params_size ALIGN_UP (sizeof (*loongson_boot_params), 8)
+#define loongson_reset_code_size (&grub_efi_loongarch64_reset_end - &grub_efi_loongarch64_reset_start)
+
+extern grub_uint8_t grub_efi_loongarch64_reset_start;
+extern grub_uint8_t grub_efi_loongarch64_reset_end;
+
+static struct
+{
+  grub_efi_loongarch64_boot_params boot_params;
+  grub_efi_loongarch64_memory_map memory_map;
+  grub_efi_loongarch64_cpu_info cpu_info;
+  grub_efi_loongarch64_system_info system_info;
+  grub_efi_loongarch64_irq_src_routing_table irq_src_routing_table;
+  grub_efi_loongarch64_interface_info interface_info;
+  grub_efi_loongarch64_special_attribute special_attribute;
+  grub_efi_loongarch64_board_devices board_devices;
+} GRUB_PACKED
+* loongson_boot_params;
+
+static void
+grub_efi_loongarch64_init_reset_system (void)
+{
+  grub_efi_loongarch64_boot_params *boot_params;
+  grub_uint8_t *reset_code_addr = (grub_uint8_t *) loongson_boot_params +
+                                  loongson_boot_params_size;
+
+  boot_params = &loongson_boot_params->boot_params;
+  grub_efi_loongarch64_reset_system_addr =
+                 (grub_uint64_t) grub_efi_system_table->runtime_services->reset_system;
+  grub_memcpy (reset_code_addr, &grub_efi_loongarch64_reset_start, loongson_reset_code_size);
+  grub_arch_sync_caches (reset_code_addr, loongson_reset_code_size);
+
+  boot_params->reset_system.reset_cold = (grub_uint64_t) reset_code_addr +
+                                         ((grub_uint64_t) &grub_efi_loongarch64_reset_cold -
+                                          (grub_uint64_t) &grub_efi_loongarch64_reset_start);
+  boot_params->reset_system.reset_warm = (grub_uint64_t) reset_code_addr +
+                                         ((grub_uint64_t) &grub_efi_loongarch64_reset_warm -
+                                          (grub_uint64_t) &grub_efi_loongarch64_reset_start);
+  boot_params->reset_system.shutdown = (grub_uint64_t) reset_code_addr +
+                                         ((grub_uint64_t) &grub_efi_loongarch64_reset_shutdown -
+                                          (grub_uint64_t) &grub_efi_loongarch64_reset_start);
+  boot_params->reset_system.do_suspend = (grub_uint64_t) reset_code_addr +
+                                         ((grub_uint64_t) &grub_efi_loongarch64_reset_suspend -
+                                          (grub_uint64_t) &grub_efi_loongarch64_reset_start);
+}
+
+static void
+grub_efi_loongarch64_init_smbios (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_smbios_table *dst = &loongson_boot_params->boot_params.efi.smbios;
+
+  dst->vers = smbios_table->vers;
+  dst->vga_bios = smbios_table->vga_bios;
+}
+
+static void
+grub_efi_loongarch64_init_cpu_info (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_cpu_info *src = (void *) smbios_table->lp.cpu_offset;
+  grub_efi_loongarch64_cpu_info *dst = &loongson_boot_params->cpu_info;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_cpu_info));
+  loongson_params->cpu_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+static void
+grub_efi_loongarch64_init_system_info (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_system_info *src = (void *) smbios_table->lp.system_offset;
+  grub_efi_loongarch64_system_info *dst = &loongson_boot_params->system_info;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_system_info));
+  loongson_params->system_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+static void
+grub_efi_loongarch64_init_irq_src_routing_table (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_irq_src_routing_table *src = (void *) smbios_table->lp.irq_offset;
+  grub_efi_loongarch64_irq_src_routing_table *dst = &loongson_boot_params->irq_src_routing_table;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_irq_src_routing_table));
+  loongson_params->irq_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+static void
+grub_efi_loongarch64_init_interface_info (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_interface_info *src = (void *) smbios_table->lp.interface_offset;
+  grub_efi_loongarch64_interface_info *dst = &loongson_boot_params->interface_info;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_interface_info));
+  loongson_params->interface_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+static void
+grub_efi_loongarch64_init_special_attribute (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_special_attribute *src = (void *) smbios_table->lp.special_offset;
+  grub_efi_loongarch64_special_attribute *dst = &loongson_boot_params->special_attribute;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_special_attribute));
+  loongson_params->special_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+static void
+grub_efi_loongarch64_init_board_devices (grub_efi_loongarch64_smbios_table *smbios_table)
+{
+  grub_efi_loongarch64_board_devices *src = (void *) smbios_table->lp.boarddev_table_offset;
+  grub_efi_loongarch64_board_devices *dst = &loongson_boot_params->board_devices;
+
+  if (!src)
+    return;
+
+  grub_memcpy (dst, src, sizeof (grub_efi_loongarch64_board_devices));
+  loongson_params->boarddev_table_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+}
+
+#define ADD_MEMORY_DESCRIPTOR(desc, size)	\
+  ((grub_efi_memory_descriptor_t *) ((char *) (desc) + (size)))
+
+static void
+grub_efi_loongarch64_init_memory_map (grub_efi_loongarch64_smbios_table *smbios_table,
+                                   grub_efi_memory_descriptor_t *mmap_buf,
+                                   grub_efi_uintn_t mmap_size,
+                                   grub_efi_uintn_t desc_size)
+{
+  grub_efi_loongarch64_memory_map *src = (void *) smbios_table->lp.memory_offset;
+  grub_efi_loongarch64_memory_map *dst = &loongson_boot_params->memory_map;
+  grub_efi_memory_descriptor_t *mmap_end;
+  grub_efi_memory_descriptor_t *desc;
+  grub_efi_memory_descriptor_t *desc_next;
+  grub_efi_uint32_t mem_types_reserved[] =
+    {
+      1, // GRUB_EFI_RESERVED_MEMORY_TYPE
+      0, // GRUB_EFI_LOADER_CODE
+      0, // GRUB_EFI_LOADER_DATA
+      0, // GRUB_EFI_BOOT_SERVICES_CODE
+      0, // GRUB_EFI_BOOT_SERVICES_DATA
+      1, // GRUB_EFI_RUNTIME_SERVICES_CODE
+      1, // GRUB_EFI_RUNTIME_SERVICES_DATA
+      0, // GRUB_EFI_CONVENTIONAL_MEMORY
+      1, // GRUB_EFI_UNUSABLE_MEMORY
+      0, // GRUB_EFI_ACPI_RECLAIM_MEMORY
+      0, // GRUB_EFI_ACPI_MEMORY_NVS
+      1, // GRUB_EFI_MEMORY_MAPPED_IO
+      1, // GRUB_EFI_MEMORY_MAPPED_IO_PORT_SPACE
+      1, // GRUB_EFI_PAL_CODE
+      1, // GRUB_EFI_PERSISTENT_MEMORY
+    };
+  grub_uint32_t need_sort = 1;
+
+  if (!src)
+    return;
+
+  dst->vers = src->vers;
+  dst->nr_map = 0;
+  dst->mem_freq = src->mem_freq;
+  loongson_params->memory_offset = (grub_uint64_t) dst - (grub_uint64_t) loongson_params;
+
+  if (!mmap_buf || !mmap_size || !desc_size)
+    return;
+
+  mmap_end = ADD_MEMORY_DESCRIPTOR (mmap_buf, mmap_size);
+
+  /* drop reserved */
+  for (desc = mmap_buf,
+       desc_next = desc;
+       desc < mmap_end;
+       desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
+    {
+      desc->type = mem_types_reserved[desc->type];
+      if (desc->type)
+        continue;
+
+      if (desc != desc_next)
+        *desc_next = *desc;
+      desc_next = ADD_MEMORY_DESCRIPTOR (desc_next, desc_size);
+    }
+  mmap_end = desc_next;
+
+  /* sort: low->high */
+  while (need_sort)
+    {
+      need_sort = 0;
+
+      for (desc = mmap_buf,
+           desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
+           (desc < mmap_end) && (desc_next < mmap_end);
+           desc = desc_next,
+           desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
+        {
+          grub_efi_memory_descriptor_t tmp;
+
+          if (desc->physical_start <= desc_next->physical_start)
+            continue;
+
+          tmp = *desc;
+          *desc = *desc_next;
+          *desc_next = tmp;
+          need_sort = 1;
+        }
+    }
+
+  /* combine continuous memory map */
+  for (desc = mmap_buf,
+       desc_next = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
+       desc_next < mmap_end;
+       desc_next = ADD_MEMORY_DESCRIPTOR (desc_next, desc_size))
+    {
+      grub_efi_physical_address_t prev_end = desc->physical_start + (desc->num_pages << 12);
+
+      if (prev_end == desc_next->physical_start)
+        {
+          desc->num_pages += desc_next->num_pages;
+          continue;
+        }
+
+      desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
+      grub_memcpy (desc, desc_next, desc_size);
+    }
+  mmap_end = ADD_MEMORY_DESCRIPTOR (desc, desc_size);
+
+  /* write to loongson memory map */
+  for (desc = mmap_buf;
+       desc < mmap_end;
+       desc = ADD_MEMORY_DESCRIPTOR (desc, desc_size))
+    {
+      grub_efi_physical_address_t physical_start = grub_vtop ((void *) desc->physical_start);
+      grub_efi_physical_address_t physical_end = physical_start + (desc->num_pages << 12);
+
+      physical_start = ALIGN_UP (physical_start, 0x100000);
+      physical_end = ALIGN_DOWN (physical_end, 0x100000);
+
+      if (physical_start >= physical_end || (physical_end - physical_start) < 0x100000)
+        continue;
+
+      dst->map[dst->nr_map].node_id = (desc->physical_start >> 44) & 0xf;
+      dst->map[dst->nr_map].mem_type = GRUB_EFI_LOONGSON_SYSTEM_RAM;
+      dst->map[dst->nr_map].mem_start = physical_start;
+      dst->map[dst->nr_map].mem_size = (physical_end - physical_start) >> 20;
+
+      grub_dprintf ("loongson", "memory map %03u: 0x%016lx 0x%016lx @ %u\n",
+                    dst->nr_map, physical_start, physical_end - physical_start,
+                    dst->map[dst->nr_map].node_id);
+
+      dst->nr_map ++;
+    }
+}
+
+#define BYTES_TO_PAGES(bytes)	(((bytes) + 0xfff) >> 12)
+#define SUB_MEMORY_DESCRIPTOR(desc, size)	\
+  ((grub_efi_memory_descriptor_t *) ((char *) (desc) - (size)))
+
+void
+grub_efi_loongarch64_alloc_boot_params (void)
+{
+  grub_efi_memory_descriptor_t *mmap_buf;
+  grub_efi_memory_descriptor_t *mmap_end;
+  grub_efi_memory_descriptor_t *desc;
+  grub_efi_uintn_t mmap_size;
+  grub_efi_uintn_t desc_size;
+  grub_efi_physical_address_t address;
+  grub_efi_allocate_type_t type;
+  grub_efi_uintn_t pages;
+  grub_efi_status_t status;
+  grub_efi_boot_services_t *b;
+  int mm_status;
+
+  type = GRUB_EFI_ALLOCATE_ADDRESS;
+  pages = BYTES_TO_PAGES (loongson_boot_params_size + loongson_reset_code_size);
+
+  mmap_size = (1 << 12);
+  mmap_buf = grub_malloc (mmap_size);
+  if (!mmap_buf)
+    grub_fatal ("out of memory!");
+
+  mm_status = grub_efi_get_memory_map (&mmap_size, mmap_buf, 0, &desc_size, 0);
+  if (mm_status == 0)
+    {
+      grub_free (mmap_buf);
+      mmap_size += desc_size * 32;
+
+      mmap_buf = grub_malloc (mmap_size);
+      if (!mmap_buf)
+        grub_fatal ("out of memory!");
+
+      mm_status = grub_efi_get_memory_map (&mmap_size, mmap_buf, 0, &desc_size, 0);
+    }
+
+  if (mm_status < 0)
+    grub_fatal ("cannot get memory map!");
+
+  mmap_end = ADD_MEMORY_DESCRIPTOR (mmap_buf, mmap_size);
+
+  for (desc = SUB_MEMORY_DESCRIPTOR (mmap_end, desc_size);
+       desc >= mmap_buf;
+       desc = SUB_MEMORY_DESCRIPTOR (desc, desc_size))
+    {
+      if (desc->type != GRUB_EFI_CONVENTIONAL_MEMORY)
+        continue;
+      if (desc->physical_start >= GRUB_EFI_MAX_USABLE_ADDRESS)
+        continue;
+      if (desc->num_pages < pages)
+        continue;
+
+      address = desc->physical_start;
+      break;
+    }
+
+  grub_free (mmap_buf);
+
+  b = grub_efi_system_table->boot_services;
+  status = efi_call_4 (b->allocate_pages, type, GRUB_EFI_RUNTIME_SERVICES_DATA, pages, &address);
+  if (status != GRUB_EFI_SUCCESS)
+    grub_fatal ("cannot allocate Loongson boot parameters!");
+
+  loongson_boot_params = (void *) ((grub_addr_t) address);
+}
+
+void
+grub_efi_loongarch64_free_boot_params (void)
+{
+  grub_efi_free_pages ((grub_addr_t) loongson_boot_params,
+                       BYTES_TO_PAGES (loongson_boot_params_size + loongson_reset_code_size));
+}
+
+void *
+grub_efi_loongarch64_get_smbios_table (void)
+{
+  static grub_efi_loongarch64_smbios_table *smbios_table; 
+  grub_efi_loongarch64_boot_params *old_boot_params;
+  struct bootparamsinterface* boot_params;
+  void * tmp_boot_params = NULL;	
+  char * p = NULL;
+  if(smbios_table)
+    return smbios_table;
+
+  tmp_boot_params = grub_efi_loongarch64_get_boot_params();
+  if(tmp_boot_params == NULL)
+  {
+    grub_dprintf("loongson", "tmp_boot_params is NULL\n");
+    return tmp_boot_params;
+  }
+ 
+  boot_params = (struct bootparamsinterface *)tmp_boot_params;
+  p = (char *)&(boot_params->signature);
+  if(grub_strncmp(p, "BPI", 3) == 0)
+  {
+    grub_dprintf("loongson", "find new bpi\n");
+    return boot_params ? boot_params : 0;
+  }
+  else
+  {
+    old_boot_params = (grub_efi_loongarch64_boot_params *)tmp_boot_params;
+    /*
+    {
+    	grub_dprintf("loongson", "smbios addr%llx\n", &old_boot_params->efi.smbios);
+    	grub_dprintf("loongson", "smbios vers%d\n", (grub_uint16_t)(&old_boot_params->efi.smbios.vers));
+    	grub_dprintf("loongson", "smbios vga_bios%d\n", &old_boot_params->efi.smbios.vga_bios);
+    	grub_dprintf("loongson", "lp memory offset %llx\n", &old_boot_params->efi.smbios.lp.memory_offset);
+    	grub_dprintf("loongson", "lp cpu offset %llx\n", &old_boot_params->efi.smbios.lp.cpu_offset);
+    	grub_dprintf("loongson", "lp system offset %llx\n", &old_boot_params->efi.smbios.lp.system_offset);
+    	grub_dprintf("loongson", "lp irq offset %llx\n", &old_boot_params->efi.smbios.lp.irq_offset);
+    	grub_dprintf("loongson", "lp interface offset %llx\n", &old_boot_params->efi.smbios.p.interface_offset);
+    	grub_dprintf("loongson", "lp special offset %llx\n", &old_boot_params->efi.smbios.lp.special_offset);
+    	grub_dprintf("loongson", "lp boarddev table offset %llx\n", &old_boot_params->efi.smbios.lp.boarddev_table_offset);
+    }
+    */
+    return old_boot_params ? &old_boot_params->efi.smbios : 0;
+  }
+
+}
+
+int
+grub_efi_is_loongarch64 (void)
+{
+  return grub_efi_loongarch64_get_smbios_table () ? 1 : 0;
+}
+
+void *
+grub_efi_loongarch64_get_boot_params (void)
+{
+  static void * boot_params = NULL;
+  grub_efi_configuration_table_t *tables;
+  grub_efi_guid_t smbios_guid = GRUB_EFI_LOONGSON_SMBIOS_TABLE_GUID;
+  unsigned int i;
+
+  if (boot_params)
+    return boot_params;
+
+  /* Look for Loongson SMBIOS in UEFI config tables. */
+  tables = grub_efi_system_table->configuration_table;
+
+  for (i = 0; i < grub_efi_system_table->num_table_entries; i++)
+    if (grub_memcmp (&tables[i].vendor_guid, &smbios_guid, sizeof (smbios_guid)) == 0)
+      {
+        boot_params= tables[i].vendor_table;
+        grub_dprintf ("loongson", "found registered SMBIOS @ %p\n", boot_params);
+        break;
+      }
+  return boot_params;
+}
+
+grub_uint8_t
+grub_efi_loongarch64_calculatesum8 (const grub_uint8_t *buffer, grub_efi_uintn_t length)
+{
+  grub_uint8_t sum;
+  grub_efi_uintn_t count;
+
+  for (sum = 0, count = 0; count < length; count++)
+  {
+    sum = (grub_uint8_t) (sum + *(buffer + count));
+  }
+  return sum;
+}
+
+grub_uint8_t
+grub_efi_loongarch64_grub_calculatechecksum8 (const grub_uint8_t *buffer, grub_efi_uintn_t length)
+{
+  grub_uint8_t checksum;
+
+  checksum = grub_efi_loongarch64_calculatesum8(buffer, length);
+
+  return (grub_uint8_t) (0x100 - checksum);
+}
+
+
+grub_uint32_t 
+grub_efi_loongarch64_memmap_sort(struct memmap array[], grub_uint32_t length, mem_map * bpmem, grub_uint32_t index, grub_uint32_t memtype)
+{
+  grub_uint64_t tempmemsize = 0;
+  grub_uint32_t j = 0;
+  grub_uint32_t t = 0;
+
+  for(j = 0; j < length;)
+  {
+    tempmemsize = array[j].memsize;
+    for(t = j + 1; t < length; t++)
+    {
+      if(array[j].memstart + tempmemsize == array[t].memstart) 
+      {
+        tempmemsize += array[t].memsize;
+      }
+      else
+      {            
+        break;
+      }
+   }
+   bpmem->map[index].memtype = memtype;
+   bpmem->map[index].memstart = array[j].memstart;
+   bpmem->map[index].memsize = tempmemsize;
+   grub_dprintf("loongson", "map[%d]:type %x, start 0x%llx, end 0x%llx\n",
+		   index,
+		   bpmem->map[index].memtype,
+		   bpmem->map[index].memstart,
+		   bpmem->map[index].memstart+ bpmem->map[index].memsize
+	       );
+   j = t;
+   index++;
+  }
+  return index;
+}
+
diff --git a/grub-core/lib/loongarch64/efi/loongarch64_asm.S b/grub-core/lib/loongarch64/efi/loongarch64_asm.S
new file mode 100644
index 000000000..99b225ea3
--- /dev/null
+++ b/grub-core/lib/loongarch64/efi/loongarch64_asm.S
@@ -0,0 +1,58 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2017  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+
+	.file 	"loongarch64_asm.S"
+	.text
+
+	.align		4
+
+VARIABLE (grub_efi_loongarch64_reset_start)
+
+VARIABLE (grub_efi_loongarch64_reset_system_addr)
+	.dword		0
+
+reset_system:
+	bl		1f
+	move		$a1, $zero
+1:
+	ld.d		$t8, $ra, -16
+	move		$a2, $zero
+	jr		$t8
+	move		$a3, $zero
+
+FUNCTION(grub_efi_loongarch64_reset_cold)
+	b		reset_system
+	li		$a0, 0
+
+FUNCTION(grub_efi_loongarch64_reset_warm)
+	b		reset_system
+	li		$a0, 1
+
+FUNCTION(grub_efi_loongarch64_reset_shutdown)
+	b		reset_system
+	li		$a0, 2
+
+FUNCTION(grub_efi_loongarch64_reset_suspend)
+	b		reset_system
+	li		$a0, 3
+
+VARIABLE (grub_efi_loongarch64_reset_end)
+
+
diff --git a/grub-core/lib/loongarch64/relocator.c b/grub-core/lib/loongarch64/relocator.c
new file mode 100644
index 000000000..fcd384c5e
--- /dev/null
+++ b/grub-core/lib/loongarch64/relocator.c
@@ -0,0 +1,160 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/mm.h>
+#include <grub/misc.h>
+
+#include <grub/types.h>
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/cache.h>
+
+#include <grub/loongarch64/relocator.h>
+#include <grub/relocator_private.h>
+
+extern grub_uint8_t grub_relocator_forward_start;
+extern grub_uint8_t grub_relocator_forward_end;
+extern grub_uint8_t grub_relocator_backward_start;
+extern grub_uint8_t grub_relocator_backward_end;
+
+#define REGW_SIZEOF (4 * sizeof (grub_uint32_t))
+#define JUMP_SIZEOF (1 * sizeof (grub_uint32_t))
+
+#define RELOCATOR_SRC_SIZEOF(x) (&grub_relocator_##x##_end \
+				 - &grub_relocator_##x##_start)
+#define RELOCATOR_SIZEOF(x)	(RELOCATOR_SRC_SIZEOF(x) \
+				 + REGW_SIZEOF * 3)
+grub_size_t grub_relocator_align = sizeof (grub_uint64_t);
+grub_size_t grub_relocator_forward_size;
+grub_size_t grub_relocator_backward_size;
+grub_size_t grub_relocator_jumper_size = JUMP_SIZEOF + REGW_SIZEOF;
+
+void
+grub_cpu_relocator_init (void)
+{
+  grub_relocator_forward_size = RELOCATOR_SIZEOF(forward);
+  grub_relocator_backward_size = RELOCATOR_SIZEOF(backward);
+}
+
+static void
+write_reg (int regn, grub_uint64_t val, void **target)
+{
+  grub_uint32_t lu12iw=0x14000000;
+  grub_uint32_t ori=0x03800000;
+  grub_uint32_t lu32id=0x16000000;
+  grub_uint32_t lu52id=0x03000000;
+
+  *(grub_uint32_t *) *target = (lu12iw | (grub_uint32_t)((val & 0xfffff000)>>12<<5) | (grub_uint32_t)regn);;
+  *target = ((grub_uint32_t *) *target) + 1;
+  *(grub_uint32_t *) *target = (ori | (grub_uint32_t)((val & 0xfff)<<10) | (grub_uint32_t)(regn | regn<<5));
+  *target = ((grub_uint32_t *) *target) + 1;
+  *(grub_uint32_t *) *target = (lu32id | (grub_uint32_t)((val & 0xfffff00000000)>>32<<5) | (grub_uint32_t)regn);;
+  *target = ((grub_uint32_t *) *target) + 1;
+  *(grub_uint32_t *) *target = (lu52id | (grub_uint32_t)((val & 0xfff0000000000000)>>52<<10) | (grub_uint32_t)(regn | regn<<5));;
+  *target = ((grub_uint32_t *) *target) + 1;
+}
+
+static void
+write_jump (int regn, void **target)
+{
+  grub_uint32_t andi=0x4c000000;
+
+  *(grub_uint32_t *) *target = (andi | (grub_uint32_t)(regn<<5));
+  *target = ((grub_uint32_t *) *target) + 1;
+}
+
+void
+grub_cpu_relocator_jumper (void *rels, grub_addr_t addr)
+{
+  write_reg (1, addr, &rels);
+  write_jump (1, &rels);
+}
+
+void
+grub_cpu_relocator_backward (void *ptr0, void *src, void *dest,
+			     grub_size_t size)
+{
+  void *ptr = ptr0;
+  write_reg (8, (grub_uint64_t) src, &ptr);
+  write_reg (9, (grub_uint64_t) dest, &ptr);
+  write_reg (10, (grub_uint64_t) size, &ptr);
+  grub_memcpy (ptr, &grub_relocator_backward_start,
+	       RELOCATOR_SRC_SIZEOF (backward));
+}
+
+void
+grub_cpu_relocator_forward (void *ptr0, void *src, void *dest,
+			     grub_size_t size)
+{
+  void *ptr = ptr0;
+  write_reg (8, (grub_uint64_t) src, &ptr);
+  write_reg (9, (grub_uint64_t) dest, &ptr);
+  write_reg (10, (grub_uint64_t) size, &ptr);
+  grub_memcpy (ptr, &grub_relocator_forward_start,
+	       RELOCATOR_SRC_SIZEOF (forward));
+}
+
+grub_err_t
+grub_relocator64_boot (struct grub_relocator *rel,
+		       struct grub_relocator64_state state)
+{
+  grub_relocator_chunk_t ch;
+  void *ptr;
+  grub_err_t err;
+  void *relst;
+  grub_size_t relsize;
+  grub_size_t stateset_size = 31 * REGW_SIZEOF + JUMP_SIZEOF;
+  unsigned i;
+  grub_addr_t vtarget;
+
+  err = grub_relocator_alloc_chunk_align (rel, &ch, 0,
+					  (0xffffffff - stateset_size)
+					  + 1, stateset_size,
+					  grub_relocator_align,
+					  GRUB_RELOCATOR_PREFERENCE_NONE, 0);
+  if (err)
+    return err;
+
+  ptr = get_virtual_current_address (ch);
+  for (i = 1; i < 32; i++)
+    write_reg (i, state.gpr[i], &ptr);
+  write_jump (state.jumpreg, &ptr);
+
+  vtarget = (grub_addr_t) grub_map_memory (get_physical_target_address (ch),
+					   stateset_size);
+
+  err = grub_relocator_prepare_relocs (rel, vtarget, &relst, &relsize);
+  if (err)
+    return err;
+
+  grub_arch_sync_caches ((void *) relst, relsize);
+
+  grub_uint64_t val;
+  __asm__ __volatile__(
+		  "li      %0, 0x4\n\t"
+		  "csrxchg $r0, %0, 0x0\n\t"
+		  : "=r"(val)
+		  :
+		  :
+		  );
+
+  ((void (*) (void)) relst) ();
+
+  /* Not reached.  */
+  return GRUB_ERR_NONE;
+}
diff --git a/grub-core/lib/loongarch64/relocator_asm.S b/grub-core/lib/loongarch64/relocator_asm.S
new file mode 100644
index 000000000..e9ebd044b
--- /dev/null
+++ b/grub-core/lib/loongarch64/relocator_asm.S
@@ -0,0 +1,50 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+
+	.p2align	4
+
+VARIABLE (grub_relocator_forward_start)
+
+copycont1:
+	ld.d $r11,$r8,0
+	st.d $r11,$r9,0
+	addi.d $r8, $r8, 8
+	addi.d $r10, $r10, -8
+	addi.d $r9, $r9, 8
+	bne $r10, $r0, copycont1
+
+VARIABLE (grub_relocator_forward_end)
+
+VARIABLE (grub_relocator_backward_start)
+
+	add.d $r9, $r9, $r10
+	add.d $r8, $r8, $r10
+	addi.d $r9, $r9, -8
+	addi.d $r8, $r8, -8
+copycont2:
+	ld.w $r11,$r8,0
+	st.w $r11,$r9,0
+	addi.d $r8, $r8, -8
+	addi.d $r10, $r10, -8
+	addi.d $r9, $r9, -8
+	bne $r10, $r0, copycont2
+
+VARIABLE (grub_relocator_backward_end)
+
diff --git a/grub-core/lib/loongarch64/setjmp.S b/grub-core/lib/loongarch64/setjmp.S
new file mode 100644
index 000000000..85f73bde3
--- /dev/null
+++ b/grub-core/lib/loongarch64/setjmp.S
@@ -0,0 +1,64 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/symbol.h>
+#include <grub/dl.h>
+#include <grub/loongarch64/asm.h>
+
+	.file	"setjmp.S"
+
+GRUB_MOD_LICENSE "GPLv3+"
+
+	.text
+
+FUNCTION(grub_setjmp)
+	GRUB_ASM_REG_S $s0, $a0,0
+	GRUB_ASM_REG_S $s1, $a0,8
+	GRUB_ASM_REG_S $s2, $a0,16
+	GRUB_ASM_REG_S $s3, $a0,24
+	GRUB_ASM_REG_S $s4, $a0,32
+	GRUB_ASM_REG_S $s5, $a0,40
+	GRUB_ASM_REG_S $s6, $a0,48
+	GRUB_ASM_REG_S $s7, $a0,56
+	GRUB_ASM_REG_S $s8, $a0,64
+	GRUB_ASM_REG_S $fp, $a0,72
+	GRUB_ASM_REG_S $sp, $a0,80
+	GRUB_ASM_REG_S $ra, $a0,88
+	move $v0, $zero
+	move $v1, $zero
+	jirl $zero,$ra,0
+
+FUNCTION(grub_longjmp)
+	GRUB_ASM_REG_L $s0, $a0,0
+	GRUB_ASM_REG_L $s1, $a0,8
+	GRUB_ASM_REG_L $s2, $a0,16
+	GRUB_ASM_REG_L $s3, $a0,24
+	GRUB_ASM_REG_L $s4, $a0,32
+	GRUB_ASM_REG_L $s5, $a0,40
+	GRUB_ASM_REG_L $s6, $a0,48
+	GRUB_ASM_REG_L $s7, $a0,56
+	GRUB_ASM_REG_L $s8, $a0,64
+	GRUB_ASM_REG_L $fp, $a0,72
+	GRUB_ASM_REG_L $sp, $a0,80
+	GRUB_ASM_REG_L $ra, $a0,88
+	addi.w $v0, $zero, 1
+	bnez $a1, .ZW0
+	addi.d $v0, $a1, 0
+.ZW0:
+	addi.d	$v1,$zero,0
+	jirl $zero,$ra,0
diff --git a/grub-core/lib/setjmp.S b/grub-core/lib/setjmp.S
index aa297ab0a..367aebde0 100644
--- a/grub-core/lib/setjmp.S
+++ b/grub-core/lib/setjmp.S
@@ -17,6 +17,8 @@
 #include "./arm64/setjmp.S"
 #elif defined(__riscv)
 #include "./riscv/setjmp.S"
+#elif defined(__loongarch64)
+#include "./loongarch64/setjmp.S"
 #else
 #error "Unknown target cpu type"
 #endif
diff --git a/grub-core/loader/loongarch64/linux.c b/grub-core/loader/loongarch64/linux.c
new file mode 100644
index 000000000..465440c05
--- /dev/null
+++ b/grub-core/loader/loongarch64/linux.c
@@ -0,0 +1,551 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/efi/api.h>
+#include <grub/efi/efi.h>
+#include <grub/elf.h>
+#include <grub/elfload.h>
+#include <grub/loader.h>
+#include <grub/dl.h>
+#include <grub/mm.h>
+#include <grub/misc.h>
+#include <grub/command.h>
+#include <grub/cpu/relocator.h>
+#include <grub/machine/loongarch64.h>
+#include <grub/memory.h>
+#include <grub/i18n.h>
+#include <grub/lib/cmdline.h>
+#include <grub/linux.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+#pragma GCC diagnostic ignored "-Wcast-align"
+
+typedef  unsigned long size_t;
+
+static grub_dl_t my_mod;
+
+static int loaded;
+
+static grub_uint32_t tmp_index = 0;
+static grub_size_t linux_size;
+
+static struct grub_relocator *relocator;
+static grub_addr_t target_addr, entry_addr;
+static int linux_argc;
+static grub_uint8_t *linux_args_addr;
+static grub_off_t rd_addr_arg_off, rd_size_arg_off;
+static int initrd_loaded = 0;
+
+static grub_uint32_t j = 0;
+static grub_uint32_t t = 0;
+grub_uint64_t tempMemsize = 0;
+grub_uint32_t free_index = 0;
+grub_uint32_t reserve_index = 0;
+grub_uint32_t acpi_table_index = 0;
+grub_uint32_t acpi_nvs_index = 0;  
+
+static inline grub_size_t
+page_align (grub_size_t size)
+{
+  return (size + (1 << 12) - 1) & (~((1 << 12) - 1));
+}
+
+/* Find the optimal number of pages for the memory map. Is it better to
+   move this code to efi/mm.c?  */
+static grub_efi_uintn_t
+find_mmap_size (void)
+{
+  static grub_efi_uintn_t mmap_size = 0;
+
+  if (mmap_size != 0)
+    return mmap_size;
+
+  mmap_size = (1 << 12);
+  while (1)
+    {
+      int ret;
+      grub_efi_memory_descriptor_t *mmap;
+      grub_efi_uintn_t desc_size;
+
+      mmap = grub_malloc (mmap_size);
+      if (! mmap)
+	return 0;
+
+      ret = grub_efi_get_memory_map (&mmap_size, mmap, 0, &desc_size, 0);
+      grub_free (mmap);
+
+      if (ret < 0)
+	{
+	  grub_error (GRUB_ERR_IO, "cannot get memory map");
+	  return 0;
+	}
+      else if (ret > 0)
+	break;
+
+      mmap_size += (1 << 12);
+    }
+  /* Increase the size a bit for safety, because GRUB allocates more on
+     later, and EFI itself may allocate more.  */
+  mmap_size += (1 << 12);
+
+  return page_align (mmap_size);
+}
+
+static grub_err_t
+grub_linux_boot (void)
+{
+  struct grub_relocator64_state state;
+  grub_int8_t checksum = 0;
+  grub_efi_memory_descriptor_t * lsdesc = NULL;
+
+  grub_memset (&state, 0, sizeof (state));
+
+  /* Boot the kernel.  */
+  state.gpr[1] = entry_addr;
+  state.gpr[4] = linux_argc;
+  state.gpr[5] = (grub_addr_t) linux_args_addr;
+
+  if(grub_efi_is_loongarch64 ())
+  {
+    grub_efi_uintn_t mmap_size;
+    grub_efi_uintn_t desc_size;
+    grub_efi_memory_descriptor_t *mmap_buf;
+    grub_err_t err;
+    struct bootparamsinterface * boot_params;
+    void * tmp_boot_params = NULL;
+    grub_efi_uint8_t new_interface_flag = 0;
+    mem_map * new_interface_mem = NULL;
+    char *p = NULL;
+
+    struct memmap reserve_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap free_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap acpi_table_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
+    struct memmap acpi_nvs_mem[GRUB_EFI_LOONGSON_MMAP_MAX];
+    
+    grub_memset(reserve_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(free_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_table_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
+    grub_memset(acpi_nvs_mem, 0, sizeof(struct memmap) * GRUB_EFI_LOONGSON_MMAP_MAX);
+
+    tmp_boot_params = grub_efi_loongarch64_get_boot_params();
+    if(tmp_boot_params == NULL)
+    {
+      grub_printf("not find param\n");
+      return -1;
+    }
+
+    boot_params = (struct bootparamsinterface *)tmp_boot_params;
+    p = (char *)&(boot_params->signature);
+    if(grub_strncmp(p, "BPI", 3) == 0)
+    {
+      /* Check extlist headers */
+      ext_list * listpointer = NULL;
+      listpointer = boot_params->extlist;
+      for( ;listpointer != NULL; listpointer = listpointer->next)
+      {
+        char *pl= (char *)&(listpointer->signature);
+        if(grub_strncmp(pl, "MEM", 3) == 0)
+        {
+          new_interface_mem = (mem_map *)listpointer;
+        }
+      }
+
+      new_interface_flag = 1;
+      grub_dprintf("loongson", "get new parameter interface\n");
+    }else{
+      new_interface_flag = 0;
+      grub_dprintf("loongson", "get old parameter interface\n");
+    }
+
+    state.gpr[6] = (grub_uint64_t)tmp_boot_params;
+    mmap_size = find_mmap_size ();
+    if (! mmap_size)
+      return grub_errno;
+    mmap_buf = grub_efi_allocate_any_pages (page_align (mmap_size) >> 12);
+    if (! mmap_buf)
+      return grub_error (GRUB_ERR_IO, "cannot allocate memory map");
+    err = grub_efi_finish_boot_services (&mmap_size, mmap_buf, NULL,
+                                         &desc_size, NULL);
+    if (err)
+      return err;
+
+    if(new_interface_flag)
+    {
+      if (!mmap_buf || !mmap_size || !desc_size)
+        return -1;
+      tmp_index = new_interface_mem -> mapcount;
+
+      /*
+       According to UEFI SPEC,mmap_buf is the accurate Memory Map array \
+       now we can fill platform specific memory structure.
+       */
+      for(lsdesc = mmap_buf; lsdesc < (grub_efi_memory_descriptor_t *)((char *)mmap_buf + mmap_size);
+                lsdesc = (grub_efi_memory_descriptor_t *)((char *)lsdesc + desc_size))
+      {
+        /* Recovery */
+        if((lsdesc->type != GRUB_EFI_ACPI_RECLAIM_MEMORY) && \
+           (lsdesc->type != GRUB_EFI_ACPI_MEMORY_NVS) && \
+           (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_DATA) && \
+           (lsdesc->type != GRUB_EFI_RUNTIME_SERVICES_CODE) && \
+           (lsdesc->type != GRUB_EFI_RESERVED_MEMORY_TYPE) && \
+           (lsdesc->type != GRUB_EFI_PAL_CODE))
+        {
+          free_mem[free_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
+          free_mem[free_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          free_mem[free_index].memsize = lsdesc->num_pages * 4096;
+          free_index++;
+
+        /*ACPI*/
+        }else if((lsdesc->type == GRUB_EFI_ACPI_RECLAIM_MEMORY)){
+          acpi_table_mem[acpi_table_index].memtype = GRUB_EFI_LOONGSON_ACPI_TABLE;
+          acpi_table_mem[acpi_table_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_table_mem[acpi_table_index].memsize = lsdesc->num_pages * 4096;
+          acpi_table_index++;
+        }else if((lsdesc->type == GRUB_EFI_ACPI_MEMORY_NVS)){
+          acpi_nvs_mem[acpi_nvs_index].memtype = GRUB_EFI_LOONGSON_ACPI_NVS;
+          acpi_nvs_mem[acpi_nvs_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          acpi_nvs_mem[acpi_nvs_index].memsize = lsdesc->num_pages * 4096;
+          acpi_nvs_index++;
+
+        /* Reserve */
+        }else{
+          reserve_mem[reserve_index].memtype = GRUB_EFI_LOONGSON_MEMORY_RESERVED;
+          reserve_mem[reserve_index].memstart = (lsdesc->physical_start) & 0xffffffffffff;
+          reserve_mem[reserve_index].memsize = lsdesc->num_pages * 4096;
+          reserve_index++;
+        }
+      }
+
+      /* Recovery sort */
+      for(j = 0; j < free_index;)
+      {
+        tempMemsize = free_mem[j].memsize;
+        for(t = j + 1; t < free_index; t++)
+        {
+          if((free_mem[j].memstart + tempMemsize == free_mem[t].memstart) && (free_mem[j].memtype == free_mem[t].memtype))
+          {
+            tempMemsize += free_mem[t].memsize;
+          }else{
+            break;
+          }
+        }
+
+        new_interface_mem->map[tmp_index].memtype = GRUB_EFI_LOONGSON_SYSTEM_RAM;
+        new_interface_mem->map[tmp_index].memstart = free_mem[j].memstart;
+        new_interface_mem->map[tmp_index].memsize = tempMemsize;
+        grub_dprintf("loongson", "map[%d]:type %x, start 0x%llx, end 0x%llx\n",
+                     tmp_index,
+                     new_interface_mem->map[tmp_index].memtype,
+                     new_interface_mem->map[tmp_index].memstart,
+                     new_interface_mem->map[tmp_index].memstart+ new_interface_mem->map[tmp_index].memsize
+                    );
+        j = t;
+        tmp_index++;
+      }
+      /*ACPI Sort*/
+      //tmp_index = grub_efi_loongson_memmap_sort(acpi_table_mem, acpi_table_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_ACPI_TABLE);
+      //tmp_index = grub_efi_loongson_memmap_sort(acpi_nvs_mem, acpi_nvs_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_ACPI_NVS);
+      /*Reserve Sort*/
+	  grub_uint64_t loongarch_addr;
+	  asm volatile ("csrrd %0, 0x181" : "=r" (loongarch_addr));
+	  if((loongarch_addr & 0xff00000000000000) == 0x9000000000000000){
+        tmp_index = grub_efi_loongarch64_memmap_sort(reserve_mem, reserve_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED);
+	  }else{
+        tmp_index = grub_efi_loongarch64_memmap_sort(reserve_mem, reserve_index, new_interface_mem, tmp_index, GRUB_EFI_LOONGSON_MEMORY_RESERVED + 1);
+	  }
+
+      new_interface_mem->mapcount = tmp_index;
+      new_interface_mem->header.checksum = 0;
+
+      checksum = grub_efi_loongarch64_grub_calculatechecksum8(new_interface_mem, new_interface_mem->header.length);
+      new_interface_mem->header.checksum = checksum;
+    }
+  }
+
+  state.jumpreg = 1;
+  grub_relocator64_boot (relocator, state);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_linux_unload (void)
+{
+  grub_relocator_unload (relocator);
+  grub_dl_unref (my_mod);
+
+  loaded = 0;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_linux_load32 (grub_elf_t elf, const char *filename)
+{
+  Elf32_Addr base;
+  grub_err_t err;
+  grub_uint8_t *playground;
+
+  /* Linux's entry point incorrectly contains a virtual address.  */
+  entry_addr = elf->ehdr.ehdr32.e_entry;
+
+  linux_size = grub_elf32_size (elf, &base, 0);
+  if (linux_size == 0)
+    return grub_errno;
+  target_addr = base;
+  linux_size = ALIGN_UP (base + linux_size - base, 8);
+
+  relocator = grub_relocator_new ();
+  if (!relocator)
+    return grub_errno;
+
+  {
+    grub_relocator_chunk_t ch;
+    err = grub_relocator_alloc_chunk_addr (relocator, &ch,
+					   grub_vtop ((void *) target_addr),
+					   linux_size);
+    if (err)
+      return err;
+    playground = get_virtual_current_address (ch);
+  }
+
+  /* Now load the segments into the area we claimed.  */
+  return grub_elf32_load (elf, filename, playground - base, GRUB_ELF_LOAD_FLAGS_NONE, 0, 0);
+}
+
+static grub_err_t
+grub_linux_load64 (grub_elf_t elf, const char *filename)
+{
+  Elf64_Addr base;
+  grub_err_t err;
+  grub_uint8_t *playground;
+
+  /* Linux's entry point incorrectly contains a virtual address.  */
+  entry_addr = elf->ehdr.ehdr64.e_entry;
+  linux_size = grub_elf64_size (elf, &base, 0);
+
+  if (linux_size == 0)
+    return grub_errno;
+  target_addr = base;
+  linux_size = ALIGN_UP (base + linux_size - base, 8);
+
+  relocator = grub_relocator_new ();
+  if (!relocator)
+    return grub_errno;
+
+  {
+    grub_relocator_chunk_t ch;
+    err = grub_relocator_alloc_chunk_addr (relocator, &ch,
+					   grub_vtop ((void *) target_addr),
+					   linux_size);
+    if (err)
+      return err;
+    playground = get_virtual_current_address (ch);
+  }
+
+  /* Now load the segments into the area we claimed.  */
+  return grub_elf64_load (elf, filename, playground - base, GRUB_ELF_LOAD_FLAGS_NONE, 0, 0);
+}
+
+static grub_err_t
+grub_cmd_linux (grub_command_t cmd __attribute__ ((unused)),
+		int argc, char *argv[])
+{
+  grub_elf_t elf = 0;
+  int size;
+  int i;
+  grub_uint64_t *linux_argv;
+  char *linux_args;
+  grub_err_t err;
+
+  if (argc == 0)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+
+  elf = grub_elf_open (argv[0],GRUB_FILE_TYPE_LINUX_KERNEL);
+  if (! elf)
+    return grub_errno;
+
+  if (elf->ehdr.ehdr32.e_type != ET_EXEC)
+    {
+      grub_elf_close (elf);
+      return grub_error (GRUB_ERR_UNKNOWN_OS,
+			 N_("this ELF file is not of the right type"));
+    }
+
+  /* Release the previously used memory.  */
+  grub_loader_unset ();
+  loaded = 0;
+
+  /* For arguments.  */
+  linux_argc = argc;
+  /* Main arguments.  */
+  size = (linux_argc) * sizeof (grub_uint64_t);
+  /* Initrd address and size.  */
+  size += 2 * sizeof (grub_uint64_t);
+  /* NULL terminator.  */
+  size += sizeof (grub_uint64_t);
+  /* First argument is always "a0".  */
+  size += ALIGN_UP (sizeof ("a0"), 4);
+  /* Normal arguments.  */
+  for (i = 1; i < argc; i++)
+    size += ALIGN_UP (grub_strlen (argv[i]) + 1, 4);
+
+  /* rd arguments.  */
+  size += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4);
+  size += ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4);
+
+  size = ALIGN_UP (size, 8);
+
+  if (grub_elf_is_elf32 (elf))
+    err = grub_linux_load32 (elf, argv[0]);
+  else
+  if (grub_elf_is_elf64 (elf))
+    err = grub_linux_load64 (elf, argv[0]);
+  else
+    err = grub_error (GRUB_ERR_BAD_OS, N_("invalid arch-dependent ELF magic"));
+
+  grub_elf_close (elf);
+
+  if (err)
+    return err;
+
+  {
+    grub_relocator_chunk_t ch;
+    err = grub_relocator_alloc_chunk_align (relocator, &ch,
+					    0, (0xffffffff - size) + 1,
+					    size, 8,
+					    GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
+    if (err)
+      return err;
+    linux_args_addr = get_virtual_current_address (ch);
+  }
+
+  linux_argv = (grub_uint64_t *) linux_args_addr;
+  linux_args = (char *) (linux_argv + (linux_argc + 1 + 2));
+
+  grub_memcpy (linux_args, "a0", sizeof ("a0"));
+  *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+  linux_argv++;
+  linux_args += ALIGN_UP (sizeof ("a0"), 4);
+
+  for (i = 1; i < argc; i++)
+    {
+      grub_memcpy (linux_args, argv[i], grub_strlen (argv[i]) + 1);
+      *linux_argv = (grub_uint64_t) (grub_addr_t) linux_args;
+      linux_argv++;
+      linux_args += ALIGN_UP (grub_strlen (argv[i]) + 1, 4);
+    }
+
+  /* Reserve space for rd arguments.  */
+  rd_addr_arg_off = (grub_uint8_t *) linux_args - linux_args_addr;
+  linux_args += ALIGN_UP (sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), 4);
+  *linux_argv = 0;
+  linux_argv++;
+
+  rd_size_arg_off = (grub_uint8_t *) linux_args - linux_args_addr;
+  linux_args += ALIGN_UP (sizeof ("rd_size=0xXXXXXXXXXXXXXXXX"), 4);
+  *linux_argv = 0;
+  linux_argv++;
+
+  *linux_argv = 0;
+
+  grub_loader_set (grub_linux_boot, grub_linux_unload, 0);
+  initrd_loaded = 0;
+  loaded = 1;
+  grub_dl_ref (my_mod);
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_cmd_initrd (grub_command_t cmd __attribute__ ((unused)),
+		 int argc, char *argv[])
+{
+  grub_size_t size = 0;
+  void *initrd_dest;
+  grub_err_t err;
+  struct grub_linux_initrd_context initrd_ctx = { 0, 0, 0 };
+
+  if (argc == 0)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("filename expected"));
+
+  if (!loaded)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, N_("you need to load the kernel first"));
+
+  if (initrd_loaded)
+    return grub_error (GRUB_ERR_BAD_ARGUMENT, "only one initrd command can be issued.");
+
+  if (grub_initrd_init (argc, argv, &initrd_ctx))
+    goto fail;
+
+  size = grub_get_initrd_size (&initrd_ctx);
+
+  {
+    grub_relocator_chunk_t ch;
+    err = grub_relocator_alloc_chunk_align (relocator, &ch,
+					    0, (0xffffffff - size) + 1,
+					    size, 0x10000,
+					    GRUB_RELOCATOR_PREFERENCE_HIGH, 0);
+
+    if (err)
+      goto fail;
+    initrd_dest = get_virtual_current_address (ch);
+  }
+
+  if (grub_initrd_load (&initrd_ctx, argv, initrd_dest))
+    goto fail;
+
+  grub_snprintf ((char *) linux_args_addr + rd_addr_arg_off,
+		 sizeof ("rd_start=0xXXXXXXXXXXXXXXXX"), "rd_start=0x%lx",
+		(grub_uint64_t) initrd_dest);
+  ((grub_uint64_t *) linux_args_addr)[linux_argc]
+    = (grub_uint64_t) ((grub_addr_t) linux_args_addr + rd_addr_arg_off);
+  linux_argc++;
+
+  grub_snprintf ((char *) linux_args_addr + rd_size_arg_off,
+		sizeof ("rd_size=0xXXXXXXXXXXXXXXXXX"), "rd_size=0x%lx",
+		(grub_uint64_t) size);
+  ((grub_uint64_t *) linux_args_addr)[linux_argc]
+    = (grub_uint64_t) ((grub_addr_t) linux_args_addr + rd_size_arg_off);
+  linux_argc++;
+
+  initrd_loaded = 1;
+
+ fail:
+  grub_initrd_close (&initrd_ctx);
+
+  return grub_errno;
+}
+
+static grub_command_t cmd_linux, cmd_initrd;
+
+GRUB_MOD_INIT(linux)
+{
+  cmd_linux = grub_register_command ("linux", grub_cmd_linux,
+				     N_("FILE [ARGS...]"), N_("Load Linux."));
+  cmd_initrd = grub_register_command ("initrd", grub_cmd_initrd,
+				      N_("FILE"), N_("Load initrd."));
+  my_mod = mod;
+}
+
+GRUB_MOD_FINI(linux)
+{
+  grub_unregister_command (cmd_linux);
+  grub_unregister_command (cmd_initrd);
+}
diff --git a/include/grub/dl.h b/include/grub/dl.h
index b3753c9ca..7ad1b45b8 100644
--- a/include/grub/dl.h
+++ b/include/grub/dl.h
@@ -301,7 +301,8 @@ grub_arch_dl_get_tramp_got_size (const void *ehdr, grub_size_t *tramp,
 #endif
 
 #if defined (__aarch64__) || defined (__sparc__) || \
-    (defined(__riscv) && (__riscv_xlen == 64))
+    (defined(__riscv) && (__riscv_xlen == 64)) || \
+    defined (__loongarch64)
 #define GRUB_ARCH_DL_TRAMP_ALIGN 8
 #define GRUB_ARCH_DL_GOT_ALIGN 8
 #endif
diff --git a/include/grub/efi/api.h b/include/grub/efi/api.h
index f1a52210c..ca151b168 100644
--- a/include/grub/efi/api.h
+++ b/include/grub/efi/api.h
@@ -1731,7 +1731,7 @@ typedef struct grub_efi_rng_protocol grub_efi_rng_protocol_t;
 
 #if (GRUB_TARGET_SIZEOF_VOID_P == 4) || defined (__ia64__) \
   || defined (__aarch64__) || defined (__MINGW64__) || defined (__CYGWIN__) \
-  || defined(__riscv)
+  || defined(__riscv) || defined (__loongarch64)
 
 #define efi_call_0(func)		func()
 #define efi_call_1(func, a)		func(a)
diff --git a/include/grub/efi/pe32.h b/include/grub/efi/pe32.h
index 0ed8781f0..433d3410a 100644
--- a/include/grub/efi/pe32.h
+++ b/include/grub/efi/pe32.h
@@ -79,6 +79,7 @@ struct grub_pe32_coff_header
 #define GRUB_PE32_MACHINE_ARM64			0xAA64
 #define GRUB_PE32_MACHINE_RISCV32		0x5032
 #define GRUB_PE32_MACHINE_RISCV64		0x5064
+#define GRUB_PE32_MACHINE_LOONGARCH64		0x6264
 
 #define GRUB_PE32_RELOCS_STRIPPED		0x0001
 #define GRUB_PE32_EXECUTABLE_IMAGE		0x0002
@@ -299,6 +300,7 @@ struct grub_pe32_fixup_block
 #define GRUB_PE32_REL_BASED_IA64_IMM64	9
 #define GRUB_PE32_REL_BASED_DIR64	10
 #define GRUB_PE32_REL_BASED_HIGH3ADJ	11
+#define GRUB_PE32_REL_BASED_LOONGARCH64	8
 
 struct grub_pe32_symbol
 {
diff --git a/include/grub/elf.h b/include/grub/elf.h
index c478933ee..5ee85f665 100644
--- a/include/grub/elf.h
+++ b/include/grub/elf.h
@@ -248,6 +248,7 @@ typedef struct
 #define EM_NUM		95
 #define EM_AARCH64	183		/* ARM 64-bit architecture */
 #define EM_RISCV	243		/* RISC-V */
+#define EM_LOONGARCH64	258		/* LoongArch64 architecture */
 
 /* If it is necessary to assign new unofficial EM_* values, please
    pick large random numbers (0x8523, 0xa7f2, etc.) to minimize the
@@ -1449,6 +1450,28 @@ typedef struct
 #define OHWA0_R4KEOP_CHECKED	0x00000001
 #define OHWA1_R4KEOP_CLEAN	0x00000002
 
+/* LOONGARCH64 relocs.  */
+#define R_LARCH_NONE	0
+#define R_LARCH_64	2
+#define R_LARCH_MARK_LA	20
+#define R_LARCH_SOP_PUSH_PCREL	22
+#define R_LARCH_SOP_PUSH_ABSOLUTE	23
+#define R_LARCH_SOP_PUSH_PLT_PCREL	29
+#define R_LARCH_SOP_SUB	32
+#define R_LARCH_SOP_SL	33
+#define R_LARCH_SOP_SR	34
+#define R_LARCH_SOP_ADD	35
+#define R_LARCH_SOP_AND	36
+#define R_LARCH_SOP_IF_ELSE	37
+#define R_LARCH_SOP_POP_32_S_10_5	38
+#define R_LARCH_SOP_POP_32_U_10_12	39
+#define R_LARCH_SOP_POP_32_S_10_12	40
+#define R_LARCH_SOP_POP_32_S_10_16	41
+#define R_LARCH_SOP_POP_32_S_10_16_S2	42
+#define R_LARCH_SOP_POP_32_S_5_20	43
+#define R_LARCH_SOP_POP_32_S_0_5_10_16_S2	44
+#define R_LARCH_SOP_POP_32_S_0_10_10_16_S2	45
+
 /* MIPS relocs.  */
 
 #define R_MIPS_NONE		0	/* No reloc */
diff --git a/include/grub/loongarch64/asm.h b/include/grub/loongarch64/asm.h
new file mode 100644
index 000000000..d6759bedd
--- /dev/null
+++ b/include/grub/loongarch64/asm.h
@@ -0,0 +1,28 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_LOONGARCH64_ASM_HEADER
+#define GRUB_LOONGARCH64_ASM_HEADER	1
+
+#define GRUB_ASM_T4 $a4
+#define GRUB_ASM_T5 $a5
+#define GRUB_ASM_SZREG 8
+#define GRUB_ASM_REG_S st.d
+#define GRUB_ASM_REG_L ld.d
+
+#endif
diff --git a/include/grub/loongarch64/efi/loader.h b/include/grub/loongarch64/efi/loader.h
new file mode 100644
index 000000000..10eccb13a
--- /dev/null
+++ b/include/grub/loongarch64/efi/loader.h
@@ -0,0 +1,25 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_LOADER_MACHINE_HEADER
+#define GRUB_LOADER_MACHINE_HEADER	1
+
+#include <grub/types.h>
+#include <grub/symbol.h>
+
+#endif /* ! GRUB_LOADER_MACHINE_HEADER */
diff --git a/include/grub/loongarch64/efi/loongarch64.h b/include/grub/loongarch64/efi/loongarch64.h
new file mode 100644
index 000000000..02426bc79
--- /dev/null
+++ b/include/grub/loongarch64/efi/loongarch64.h
@@ -0,0 +1,290 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_EFI_LOONGSON_HEADER
+#define GRUB_EFI_LOONGSON_HEADER 1
+
+#include <grub/types.h>
+
+#include <grub/efi/api.h>
+
+#define GRUB_EFI_LOONGSON_SMBIOS_TABLE_GUID	\
+  { 0x4660f721, 0x2ec5, 0x416a, \
+    { 0x89, 0x9a, 0x43, 0x18, 0x02, 0x50, 0xa0, 0xc9 } \
+  }
+
+#define GRUB_EFI_LOONGSON_MMAP_MAX 128
+typedef enum
+  {                   
+    GRUB_EFI_LOONGSON_SYSTEM_RAM = 1,
+    GRUB_EFI_LOONGSON_MEMORY_RESERVED,
+    GRUB_EFI_LOONGSON_ACPI_TABLE,
+    GRUB_EFI_LOONGSON_ACPI_NVS,
+    GRUB_EFI_LOONGSON_MAX_MEMORY_TYPE
+  }
+grub_efi_loongarch64_memory_type;
+
+typedef struct
+{
+  grub_uint16_t vers;     /* version */
+  grub_uint32_t nr_map;   /* number of memory_maps */
+  grub_uint32_t mem_freq; /* memory frequence */
+  struct mem_map {
+    grub_uint32_t node_id;        /* node_id which memory attached to */
+    grub_uint32_t mem_type;       /* system memory, pci memory, pci io, etc. */
+    grub_uint64_t mem_start;      /* memory map start address */
+    grub_uint32_t mem_size;       /* each memory_map size, not the total size */
+  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
+} GRUB_PACKED
+grub_efi_loongarch64_memory_map;
+
+/*
+ * Capability and feature descriptor structure for LOONGARCH CPU
+ */
+typedef struct
+{
+  grub_uint16_t vers;         /* version */
+  grub_uint32_t processor_id; /* PRID, e.g. 6305, 6306 */
+  grub_uint32_t cputype;      /* Loongson_3A/3B, etc. */
+  grub_uint32_t total_node;   /* num of total numa nodes */
+  grub_uint16_t cpu_startup_core_id; /* Boot core id */
+  grub_uint16_t reserved_cores_mask;
+  grub_uint32_t cpu_clock_freq; /* cpu_clock */
+  grub_uint32_t nr_cpus;
+} GRUB_PACKED
+grub_efi_loongarch64_cpu_info;
+
+#define GRUB_EFI_LOONGSON_MAX_UARTS 64
+
+typedef struct
+{
+  grub_uint32_t iotype; /* see include/linux/serial_core.h */
+  grub_uint32_t uartclk;
+  grub_uint32_t int_offset;
+  grub_uint64_t uart_base;
+} GRUB_PACKED
+grub_efi_loongarch64_uart_device;
+
+#define GRUB_EFI_LOONGSON_MAX_SENSORS 64
+
+typedef struct
+{
+  char name[32];   /* a formal name */
+  char label[64];  /* a flexible description */
+  grub_uint32_t type;        /* SENSOR_* */
+  grub_uint32_t id;          /* instance id of a sensor-class */
+  grub_uint32_t fan_policy;
+  grub_uint32_t fan_percent; /* only for constant speed policy */
+  grub_uint64_t base_addr;   /* base address of device registers */
+} GRUB_PACKED
+grub_efi_loongarch64_sensor_device;
+
+typedef struct
+{
+  grub_uint16_t vers;     /* version */
+  grub_uint32_t ccnuma_smp; /* 0: no numa; 1: has numa */
+  grub_uint32_t sing_double_channel; /* 1:single; 2:double */
+  grub_uint32_t nr_uarts;
+  grub_efi_loongarch64_uart_device uarts[GRUB_EFI_LOONGSON_MAX_UARTS];
+  grub_uint32_t nr_sensors;
+  grub_efi_loongarch64_sensor_device sensors[GRUB_EFI_LOONGSON_MAX_SENSORS];
+  char has_ec;
+  char ec_name[32];
+  grub_uint64_t ec_base_addr;
+  char has_tcm;
+  char tcm_name[32];
+  grub_uint64_t tcm_base_addr;
+  grub_uint64_t workarounds; /* see workarounds.h */
+} GRUB_PACKED
+grub_efi_loongarch64_system_info;
+
+typedef struct
+{
+  grub_uint16_t vers;
+  grub_uint16_t size;
+  grub_uint16_t rtr_bus;
+  grub_uint16_t rtr_devfn;
+  grub_uint32_t vendor;
+  grub_uint32_t device;
+  grub_uint32_t PIC_type;   /* conform use HT or PCI to route to CPU-PIC */
+  grub_uint64_t ht_int_bit; /* 3A: 1<<24; 3B: 1<<16 */
+  grub_uint64_t ht_enable;  /* irqs used in this PIC */
+  grub_uint32_t node_id;    /* node id: 0x0-0; 0x1-1; 0x10-2; 0x11-3 */
+  grub_uint64_t pci_mem_start_addr;
+  grub_uint64_t pci_mem_end_addr;
+  grub_uint64_t pci_io_start_addr;
+  grub_uint64_t pci_io_end_addr;
+  grub_uint64_t pci_config_addr;
+  grub_uint32_t dma_mask_bits;
+} GRUB_PACKED
+grub_efi_loongarch64_irq_src_routing_table;
+
+typedef struct
+{
+  grub_uint16_t vers; /* version */
+  grub_uint16_t size;
+  grub_uint8_t  flag;
+  char description[64];
+} GRUB_PACKED
+grub_efi_loongarch64_interface_info;
+
+#define GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER 128
+
+typedef struct
+{
+  grub_uint64_t start; /* resource start address */
+  grub_uint64_t end;   /* resource end address */
+  char name[64];
+  grub_uint32_t flags;
+}
+grub_efi_loongarch64_resource;
+
+/* arch specific additions */
+typedef struct
+{
+}
+grub_efi_loongarch64_archdev_data;
+
+typedef struct
+{
+  char name[64];    /* hold the device name */
+  grub_uint32_t num_resources; /* number of device_resource */
+  /* for each device's resource */
+  grub_efi_loongarch64_resource resource[GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER];
+  /* arch specific additions */
+  grub_efi_loongarch64_archdev_data archdata;
+}
+grub_efi_loongarch64_board_devices;
+
+typedef struct
+{
+  grub_uint16_t vers;     /* version */
+  char special_name[64]; /* special_atribute_name */
+  grub_uint32_t loongarch64_special_type; /* type of special device */
+  /* for each device's resource */
+  grub_efi_loongarch64_resource resource[GRUB_EFI_LOONGSON_MAX_RESOURCE_NUMBER];
+}
+grub_efi_loongarch64_special_attribute;
+
+typedef struct
+{
+  grub_uint64_t memory_offset;
+  grub_uint64_t cpu_offset;
+  grub_uint64_t system_offset;
+  grub_uint64_t irq_offset;
+  grub_uint64_t interface_offset;
+  grub_uint64_t special_offset;
+  grub_uint64_t boarddev_table_offset;
+}
+grub_efi_loongarch64_params;
+
+typedef struct
+{
+  grub_uint16_t vers;     /* version */
+  grub_uint64_t vga_bios; /* vga_bios address */
+  grub_efi_loongarch64_params lp;
+}
+grub_efi_loongarch64_smbios_table;
+
+typedef struct
+{
+  grub_uint64_t reset_cold;
+  grub_uint64_t reset_warm;
+  grub_uint64_t reset_type;
+  grub_uint64_t shutdown;
+  grub_uint64_t do_suspend; /* NULL if not support */
+}
+grub_efi_loongarch64_reset_system;
+
+typedef struct
+{
+  grub_uint64_t mps;    /* MPS table */
+  grub_uint64_t acpi;   /* ACPI table (IA64 ext 0.71) */
+  grub_uint64_t acpi20; /* ACPI table (ACPI 2.0) */
+  grub_efi_loongarch64_smbios_table smbios; /* SM BIOS table */
+  grub_uint64_t sal_systab; /* SAL system table */
+  grub_uint64_t boot_info;  /* boot info table */
+}
+grub_efi_loongarch64;
+
+typedef struct
+{
+  grub_efi_loongarch64 efi;
+  grub_efi_loongarch64_reset_system reset_system;
+}
+grub_efi_loongarch64_boot_params;
+
+extern grub_uint64_t grub_efi_loongarch64_reset_system_addr;
+
+extern void grub_efi_loongarch64_reset_cold (void);
+extern void grub_efi_loongarch64_reset_warm (void);
+extern void grub_efi_loongarch64_reset_shutdown (void);
+extern void grub_efi_loongarch64_reset_suspend (void);
+
+void grub_efi_loongarch64_alloc_boot_params (void);
+void grub_efi_loongarch64_free_boot_params (void);
+void * grub_efi_loongarch64_get_smbios_table (void);
+
+int EXPORT_FUNC(grub_efi_is_loongarch64) (void);
+
+grub_uint8_t
+EXPORT_FUNC(grub_efi_loongarch64_calculatesum8) (const grub_uint8_t *Buffer, grub_efi_uintn_t Length);
+
+grub_uint8_t
+EXPORT_FUNC(grub_efi_loongarch64_grub_calculatechecksum8) (const grub_uint8_t *Buffer, grub_efi_uintn_t Length);
+
+
+void *
+EXPORT_FUNC(grub_efi_loongarch64_get_boot_params) (void);
+
+typedef struct _extention_list_hdr{
+  grub_uint64_t  signature;
+  grub_uint32_t  length;
+  grub_uint8_t   revision;
+  grub_uint8_t   checksum;
+  struct  _extention_list_hdr *next;
+}GRUB_PACKED
+ext_list;
+
+typedef struct bootparamsinterface {
+  grub_uint64_t           signature;    //{'B', 'P', 'I', '_', '0', '_', '1'}
+  grub_efi_system_table_t *systemtable;
+  ext_list         *extlist;
+}GRUB_PACKED
+bootparamsinterface;
+
+typedef struct {
+  ext_list  header;         //  {'M', 'E', 'M'}
+  grub_uint8_t mapcount;
+  struct GRUB_PACKED memmap {
+    grub_uint32_t memtype;
+    grub_uint64_t memstart;
+    grub_uint64_t memsize;
+  } map[GRUB_EFI_LOONGSON_MMAP_MAX];
+}GRUB_PACKED
+mem_map;
+
+typedef struct {
+  ext_list header;          // {VBIOS}
+  grub_uint64_t  vbiosaddr;
+}GRUB_PACKED
+vbios;
+
+grub_uint32_t 
+EXPORT_FUNC (grub_efi_loongarch64_memmap_sort) (struct memmap array[], grub_uint32_t length, mem_map * bpmem, grub_uint32_t index, grub_uint32_t memtype);
+#endif /* ! GRUB_EFI_LOONGSON_HEADER */
diff --git a/include/grub/loongarch64/efi/memory.h b/include/grub/loongarch64/efi/memory.h
new file mode 100644
index 000000000..2e8001f5a
--- /dev/null
+++ b/include/grub/loongarch64/efi/memory.h
@@ -0,0 +1,32 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_MEMORY_CPU_HEADER
+#include <grub/efi/memory.h>
+
+static inline grub_uint64_t
+grub_efi_max_usable_address(void)
+{
+  grub_uint64_t addr;
+  asm volatile ("csrrd %0, 0x181" : "=r" (addr));
+  return addr |= 0xffffffffffUL;
+}
+
+#define GRUB_EFI_MAX_USABLE_ADDRESS grub_efi_max_usable_address()
+
+#endif
diff --git a/include/grub/loongarch64/io.h b/include/grub/loongarch64/io.h
new file mode 100644
index 000000000..5105b8b0b
--- /dev/null
+++ b/include/grub/loongarch64/io.h
@@ -0,0 +1,61 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef	GRUB_IO_H
+#define	GRUB_IO_H	1
+
+#include <grub/types.h>
+
+typedef grub_addr_t grub_port_t;
+
+static __inline unsigned char
+grub_inb (grub_port_t port)
+{
+  return *(volatile grub_uint8_t *) port;
+}
+
+static __inline unsigned short int
+grub_inw (grub_port_t port)
+{ return *(volatile grub_uint16_t *) port;
+}
+
+static __inline unsigned int
+grub_inl (grub_port_t port)
+{
+  return *(volatile grub_uint32_t *) port;
+}
+
+static __inline void
+grub_outb (unsigned char value, grub_port_t port)
+{
+  *(volatile grub_uint8_t *) port = value;
+}
+
+static __inline void
+grub_outw (unsigned short int value, grub_port_t port)
+{
+  *(volatile grub_uint16_t *) port = value;
+}
+
+static __inline void
+grub_outl (unsigned int value, grub_port_t port)
+{
+  *(volatile grub_uint32_t *) port = value;
+}
+
+#endif /* _SYS_IO_H */
diff --git a/include/grub/loongarch64/kernel.h b/include/grub/loongarch64/kernel.h
new file mode 100644
index 000000000..bd87e5a06
--- /dev/null
+++ b/include/grub/loongarch64/kernel.h
@@ -0,0 +1,24 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_KERNEL_CPU_HEADER
+#define GRUB_KERNEL_CPU_HEADER	1
+
+#include <grub/symbol.h>
+
+#endif /* ! GRUB_KERNEL_MACHINE_HEADER */
diff --git a/include/grub/loongarch64/loongarch64.h b/include/grub/loongarch64/loongarch64.h
new file mode 100644
index 000000000..637419832
--- /dev/null
+++ b/include/grub/loongarch64/loongarch64.h
@@ -0,0 +1,28 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_REGISTERS_CPU_HEADER
+#define GRUB_REGISTERS_CPU_HEADER	1
+
+#ifdef ASM_FILE
+#define GRUB_CPU_REGISTER_WRAP(x) x
+#else
+#define GRUB_CPU_REGISTER_WRAP(x) #x
+#endif
+
+#endif
diff --git a/include/grub/loongarch64/memory.h b/include/grub/loongarch64/memory.h
new file mode 100644
index 000000000..3478384be
--- /dev/null
+++ b/include/grub/loongarch64/memory.h
@@ -0,0 +1,54 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_MEMORY_CPU_HEADER
+#define GRUB_MEMORY_CPU_HEADER	1
+
+#ifndef ASM_FILE
+#include <grub/symbol.h>
+#include <grub/err.h>
+#include <grub/types.h>
+#endif
+
+#ifndef ASM_FILE
+
+typedef grub_addr_t grub_phys_addr_t;
+
+static inline grub_phys_addr_t
+grub_vtop (void *a)
+{
+  return ((grub_phys_addr_t) a) & 0xffffffffffffUL;
+}
+
+static inline void *
+grub_map_memory (grub_phys_addr_t a, grub_size_t size)
+{
+  grub_uint64_t addr;
+  asm volatile ("csrrd %0, 0x181" : "=r" (addr));
+  return (void *) (a | (addr & 0xffffffffffffff00UL));
+}
+
+static inline void
+grub_unmap_memory (void *a __attribute__ ((unused)),
+		   grub_size_t size __attribute__ ((unused)))
+{
+}
+
+#endif
+
+#endif
diff --git a/include/grub/loongarch64/relocator.h b/include/grub/loongarch64/relocator.h
new file mode 100644
index 000000000..df2d05ffd
--- /dev/null
+++ b/include/grub/loongarch64/relocator.h
@@ -0,0 +1,36 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_RELOCATOR_CPU_HEADER
+#define GRUB_RELOCATOR_CPU_HEADER	1
+
+#include <grub/types.h>
+#include <grub/err.h>
+#include <grub/relocator.h>
+
+struct grub_relocator64_state
+{
+  grub_uint64_t gpr[32];
+  int jumpreg;
+};
+
+grub_err_t
+grub_relocator64_boot (struct grub_relocator *rel,
+		       struct grub_relocator64_state state);
+
+#endif 
diff --git a/include/grub/loongarch64/setjmp.h b/include/grub/loongarch64/setjmp.h
new file mode 100644
index 000000000..e469b72fb
--- /dev/null
+++ b/include/grub/loongarch64/setjmp.h
@@ -0,0 +1,27 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_SETJMP_CPU_HEADER
+#define GRUB_SETJMP_CPU_HEADER	1
+
+typedef grub_uint64_t grub_jmp_buf[12];
+
+int grub_setjmp (grub_jmp_buf env) RETURNS_TWICE;
+void grub_longjmp (grub_jmp_buf env, int val) __attribute__ ((noreturn));
+
+#endif
diff --git a/include/grub/loongarch64/time.h b/include/grub/loongarch64/time.h
new file mode 100644
index 000000000..77f7b016b
--- /dev/null
+++ b/include/grub/loongarch64/time.h
@@ -0,0 +1,36 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KERNEL_CPU_TIME_HEADER
+#define KERNEL_CPU_TIME_HEADER	1
+
+#ifndef GRUB_UTIL
+
+#define GRUB_TICKS_PER_SECOND	(grub_arch_cpuclock / 2)
+
+void grub_timer_init (grub_uint32_t cpuclock);
+
+extern grub_uint32_t grub_arch_cpuclock;
+#endif
+
+static inline void
+grub_cpu_idle(void)
+{
+}
+
+#endif
diff --git a/include/grub/loongarch64/types.h b/include/grub/loongarch64/types.h
new file mode 100644
index 000000000..a7365930d
--- /dev/null
+++ b/include/grub/loongarch64/types.h
@@ -0,0 +1,29 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2021  Loongson Technology Corporation Limited, 
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef GRUB_TYPES_CPU_HEADER
+#define GRUB_TYPES_CPU_HEADER	1
+
+#define GRUB_TARGET_SIZEOF_VOID_P	8
+#define GRUB_TARGET_SIZEOF_LONG		8
+
+#ifdef GRUB_CPU_LOONGARCH
+#undef GRUB_TARGET_WORDS_BIGENDIAN
+#endif
+
+#endif
diff --git a/include/grub/util/install.h b/include/grub/util/install.h
index 7df3191f4..6d3436db8 100644
--- a/include/grub/util/install.h
+++ b/include/grub/util/install.h
@@ -109,6 +109,7 @@ enum grub_install_plat
     GRUB_INSTALL_PLATFORM_ARM_COREBOOT,
     GRUB_INSTALL_PLATFORM_RISCV32_EFI,
     GRUB_INSTALL_PLATFORM_RISCV64_EFI,
+    GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI,
     GRUB_INSTALL_PLATFORM_MAX
   };
 
diff --git a/util/grub-install-common.c b/util/grub-install-common.c
index 4e212e690..b34c9e06b 100644
--- a/util/grub-install-common.c
+++ b/util/grub-install-common.c
@@ -902,6 +902,7 @@ static struct
     [GRUB_INSTALL_PLATFORM_ARM_COREBOOT] =     { "arm",     "coreboot"  },
     [GRUB_INSTALL_PLATFORM_RISCV32_EFI] =      { "riscv32", "efi"       },
     [GRUB_INSTALL_PLATFORM_RISCV64_EFI] =      { "riscv64", "efi"       },
+    [GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI] =  { "loongarch64", "efi"   },
   }; 
 
 char *
diff --git a/util/grub-install.c b/util/grub-install.c
index 0fbe7f78c..2d46fee03 100644
--- a/util/grub-install.c
+++ b/util/grub-install.c
@@ -322,6 +322,8 @@ get_default_platform (void)
    return grub_install_get_default_arm_platform ();
 #elif defined (__aarch64__)
    return "arm64-efi";
+#elif defined (__loongarch64)
+   return "loongarch64-efi";
 #elif defined (__amd64__) || defined (__x86_64__) || defined (__i386__)
    return grub_install_get_default_x86_platform ();
 #elif defined (__riscv)
@@ -487,6 +489,7 @@ have_bootdev (enum grub_install_plat pl)
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_I386_IEEE1275:
     case GRUB_INSTALL_PLATFORM_SPARC64_IEEE1275:
     case GRUB_INSTALL_PLATFORM_POWERPC_IEEE1275:
@@ -912,6 +915,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
     case GRUB_INSTALL_PLATFORM_I386_IEEE1275:
     case GRUB_INSTALL_PLATFORM_SPARC64_IEEE1275:
@@ -959,6 +963,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
     case GRUB_INSTALL_PLATFORM_I386_IEEE1275:
     case GRUB_INSTALL_PLATFORM_ARM_UBOOT:
@@ -1014,6 +1019,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
       is_efi = 1;
       break;
@@ -1133,6 +1139,9 @@ main (int argc, char *argv[])
 	    case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
 	      efi_file = "BOOTRISCV64.EFI";
 	      break;
+	    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
+	      efi_file = "BOOTLOONGARCH64.EFI";
+	      break;
 	    default:
 	      grub_util_error ("%s", _("You've found a bug"));
 	      break;
@@ -1166,6 +1175,9 @@ main (int argc, char *argv[])
 	    case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
 	      efi_file = "grubriscv64.efi";
 	      break;
+	    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
+	      efi_file = "grubloongarch64.efi";
+	      break;
 	    default:
 	      efi_file = "grub.efi";
 	      break;
@@ -1470,6 +1482,7 @@ main (int argc, char *argv[])
 		  case GRUB_INSTALL_PLATFORM_ARM64_EFI:
 		  case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
 		  case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+		  case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
 		  case GRUB_INSTALL_PLATFORM_IA64_EFI:
 		    g = grub_util_guess_efi_drive (*curdev);
 		    break;
@@ -1565,6 +1578,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
       core_name = "core.efi";
       snprintf (mkimage_target, sizeof (mkimage_target),
@@ -1670,6 +1684,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
     case GRUB_INSTALL_PLATFORM_MIPSEL_QEMU_MIPS:
     case GRUB_INSTALL_PLATFORM_MIPS_QEMU_MIPS:
@@ -1924,6 +1939,7 @@ main (int argc, char *argv[])
     case GRUB_INSTALL_PLATFORM_ARM64_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV32_EFI:
     case GRUB_INSTALL_PLATFORM_RISCV64_EFI:
+    case GRUB_INSTALL_PLATFORM_LOONGARCH64_EFI:
     case GRUB_INSTALL_PLATFORM_IA64_EFI:
       {
 	char *dst = grub_util_path_concat (2, efidir, efi_file);
diff --git a/util/grub-mkimagexx.c b/util/grub-mkimagexx.c
index d78fa3e53..5dfb01c06 100644
--- a/util/grub-mkimagexx.c
+++ b/util/grub-mkimagexx.c
@@ -61,6 +61,8 @@
 #endif
 #endif
 
+#define RELOC_STACK_MAX 1024
+
 /* These structures are defined according to the CHRP binding to IEEE1275,
    "Client Program Format" section.  */
 
@@ -784,6 +786,9 @@ SUFFIX (relocate_addrs) (Elf_Ehdr *e, struct section_metadata *smd,
   struct grub_ia64_trampoline *tr = (void *) (pe_target + tramp_off);
   grub_uint64_t *gpptr = (void *) (pe_target + got_off);
   unsigned unmatched_adr_got_page = 0;
+  grub_uint64_t oprs[RELOC_STACK_MAX]={0};
+  int opri=-1;
+  grub_uint32_t la_abs = 0;
 #define MASK19 ((1 << 19) - 1)
 #else
   grub_uint32_t *tr = (void *) (pe_target + tramp_off);
@@ -839,10 +844,10 @@ SUFFIX (relocate_addrs) (Elf_Ehdr *e, struct section_metadata *smd,
 	    offset = grub_target_to_host (r->r_offset);
 	    target = SUFFIX (get_target_address) (e, target_section,
 						  offset, image_target);
+
 	    info = grub_target_to_host (r->r_info);
 	    sym_addr = SUFFIX (get_symbol_address) (e, smd->symtab,
 						    ELF_R_SYM (info), image_target);
-
             addend = (s->sh_type == grub_target_to_host32 (SHT_RELA)) ?
 	      grub_target_to_host (r->r_addend) : 0;
 
@@ -1123,6 +1128,173 @@ SUFFIX (relocate_addrs) (Elf_Ehdr *e, struct section_metadata *smd,
 		   }
 	       break;
 	       }
+	     case EM_LOONGARCH64:
+	       {
+		 sym_addr += addend;
+		 switch (ELF_R_TYPE (info))
+		   {
+			case R_LARCH_64:
+				{
+				*target=(grub_uint64_t)sym_addr;
+				}
+				break;
+			case R_LARCH_MARK_LA:
+				{
+				la_abs=1;
+				}
+				break;
+			case R_LARCH_SOP_PUSH_PCREL:
+				{
+				opri++;
+				oprs[opri]=(grub_uint64_t)(sym_addr-(target_section_addr+offset+image_target->vaddr_offset));
+				}
+				break;
+			case R_LARCH_SOP_PUSH_ABSOLUTE:
+				{
+				opri++;
+				oprs[opri]=(grub_uint64_t)sym_addr;
+				}
+				break;
+			case R_LARCH_SOP_PUSH_PLT_PCREL:
+				{
+				opri++;
+				oprs[opri]=(grub_uint64_t)(sym_addr-(target_section_addr+offset+image_target->vaddr_offset));
+				}
+				break;
+			case R_LARCH_SOP_SUB:
+				{
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				opri++;
+				oprs[opri]=opr1 - opr2;
+				}
+				break;
+			case R_LARCH_SOP_SL:
+				{
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				opri++;
+				oprs[opri]=opr1 << opr2;
+				}
+				break;
+			case R_LARCH_SOP_SR:
+				{
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				opri++;
+				oprs[opri]=opr1 >> opr2;
+				}
+				break;
+			case R_LARCH_SOP_ADD:
+				{
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				opri++;
+				oprs[opri]=opr1 + opr2;
+				}
+				break;
+			case R_LARCH_SOP_AND:
+				{
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				opri++;
+				oprs[opri]=opr1 & opr2;
+				}
+				break;
+			case R_LARCH_SOP_IF_ELSE:
+				{
+				grub_uint64_t opr3=oprs[opri];
+				opri--;
+				grub_uint64_t opr2=oprs[opri];
+				opri--;
+				grub_uint64_t opr1=oprs[opri];
+				opri--;
+				if(opr1){
+					opri++;
+					oprs[opri]=opr2;
+				} else {
+					opri++;
+					oprs[opri]=opr3;
+				}
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_10_5:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target=(*target) | ((opr1 & 0x1f) << 10);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_U_10_12:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target=(*target) | ((opr1 & 0xfff) << 10);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_10_12:
+				{
+				if(la_abs==1)
+					la_abs=0;
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target = (*target) | ((opr1 & 0xfff) << 10);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_10_16:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target = (*target) | ((opr1 & 0xffff) << 10);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_10_16_S2:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target = (*target) | (((opr1 >> 2) & 0xffff) << 10);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_5_20:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target = (*target) | ((opr1 & 0xfffff)<<5)	;
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target =(*target) | (((opr1 >> 2) & 0xffff) << 10);
+				*target =(*target) | ((opr1 >> 18) & 0x1f);
+				}
+				break;
+			case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+				{
+				grub_uint64_t opr1 = oprs[opri];
+				opri--;
+				*target =(*target) | (((opr1 >> 2) & 0xffff) << 10);
+				*target =(*target) | ((opr1 >> 18) & 0x3ff);
+				}
+				break;
+		   default:
+		     grub_util_error (_("relocation 0x%x is not implemented yet"),
+				      (unsigned int) ELF_R_TYPE (info));
+		     break;
+		   }
+	       break;
+	       }
 #endif
 #if defined(MKIMAGE_ELF32)
 	     case EM_ARM:
@@ -1501,7 +1673,8 @@ add_fixup_entry (struct fixup_block_list **cblock, grub_uint16_t type,
 
 	  /* The spec does not mention the requirement of a Page RVA.
 	     Here, align the address with a 4K boundary for safety.  */
-	  b->page_rva = (addr & ~(0x1000 - 1));
+	  if (type)
+	    b->page_rva = (addr & ~(0x1000 - 1));
 	  b->block_size = sizeof (*b);
 	}
 
@@ -1557,6 +1730,8 @@ static void
 translate_relocation_pe (struct translate_context *ctx,
 			 Elf_Addr addr,
 			 Elf_Addr info,
+			 Elf_Addr sym_addr,
+			 Elf_Addr addend,
 			 const struct grub_install_image_target_desc *image_target)
 {
   /* Necessary to relocate only absolute addresses.  */
@@ -1668,6 +1843,52 @@ translate_relocation_pe (struct translate_context *ctx,
 	}
       break;
       break;
+    case EM_LOONGARCH64:
+      switch (ELF_R_TYPE (info))
+	{
+	case R_LARCH_64:
+		{
+		ctx->current_address = add_fixup_entry (
+		 &ctx->lst,
+		 GRUB_PE32_REL_BASED_DIR64,
+		 addr, 0, ctx->current_address,
+		 image_target);
+		}
+		break;
+	case R_LARCH_MARK_LA:
+		{
+		ctx->current_address = add_fixup_entry (
+		 &ctx->lst,
+		 GRUB_PE32_REL_BASED_LOONGARCH64,
+		 addr, 0, ctx->current_address,
+		 image_target);
+		}
+		break;
+	case R_LARCH_NONE:
+	case R_LARCH_SOP_PUSH_PCREL:
+	case R_LARCH_SOP_PUSH_ABSOLUTE:
+	case R_LARCH_SOP_PUSH_PLT_PCREL:
+	case R_LARCH_SOP_SUB:
+	case R_LARCH_SOP_SL:
+	case R_LARCH_SOP_SR:
+	case R_LARCH_SOP_ADD:
+	case R_LARCH_SOP_AND:
+	case R_LARCH_SOP_IF_ELSE:
+	case R_LARCH_SOP_POP_32_S_10_5:
+	case R_LARCH_SOP_POP_32_U_10_12:
+	case R_LARCH_SOP_POP_32_S_10_12:
+	case R_LARCH_SOP_POP_32_S_10_16:
+	case R_LARCH_SOP_POP_32_S_10_16_S2:
+	case R_LARCH_SOP_POP_32_S_5_20:
+	case R_LARCH_SOP_POP_32_S_0_5_10_16_S2:
+	case R_LARCH_SOP_POP_32_S_0_10_10_16_S2:
+		break;
+	default:
+	  grub_util_error (_("relocation 0x%x is not implemented yet"),
+			   (unsigned int) ELF_R_TYPE (info));
+	  break;
+	}
+      break;
 #if defined(MKIMAGE_ELF32)
     case EM_ARM:
       switch (ELF_R_TYPE (info))
@@ -1825,10 +2046,12 @@ static void
 translate_relocation (struct translate_context *ctx,
 		      Elf_Addr addr,
 		      Elf_Addr info,
+		      Elf_Addr sym_addr,
+		      Elf_Addr addend,
 		      const struct grub_install_image_target_desc *image_target)
 {
   if (image_target->id == IMAGE_EFI)
-    translate_relocation_pe (ctx, addr, info, image_target);
+    translate_relocation_pe (ctx, addr, info, sym_addr, addend, image_target);
   else
     translate_relocation_raw (ctx, addr, info, image_target);
 }
@@ -1969,12 +2192,18 @@ make_reloc_section (Elf_Ehdr *e, struct grub_mkimage_layout *layout,
     if ((grub_target_to_host32 (s->sh_type) == SHT_REL) ||
         (grub_target_to_host32 (s->sh_type) == SHT_RELA))
       {
-	Elf_Rel *r;
+	Elf_Rela *r;
 	Elf_Word rtab_size, r_size, num_rs;
 	Elf_Off rtab_offset;
+	Elf_Shdr *symtab_section;
 	Elf_Addr section_address;
 	Elf_Word j;
 
+	symtab_section = (Elf_Shdr *) ((char *) smd->sections
+					+ (grub_target_to_host32 (s->sh_link)
+						* smd->section_entsize));
+
+
 	if (!SUFFIX (is_kept_reloc_section) (s, image_target, smd))
 	  {
 	    grub_util_info ("not translating the skipped relocation section %s",
@@ -1992,20 +2221,30 @@ make_reloc_section (Elf_Ehdr *e, struct grub_mkimage_layout *layout,
 
 	section_address = smd->vaddrs[grub_le_to_cpu32 (s->sh_info)];
 
-	for (j = 0, r = (Elf_Rel *) ((char *) e + rtab_offset);
+	for (j = 0, r = (Elf_Rela *) ((char *) e + rtab_offset);
 	     j < num_rs;
-	     j++, r = (Elf_Rel *) ((char *) r + r_size))
+	     j++, r = (Elf_Rela *) ((char *) r + r_size))
 	  {
 	    Elf_Addr info;
 	    Elf_Addr offset;
 	    Elf_Addr addr;
+	    Elf_Addr sym_addr;
+	    Elf_Addr addend;
 
 	    offset = grub_target_to_host (r->r_offset);
-	    info = grub_target_to_host (r->r_info);
+	    if (image_target->elf_target == EM_MIPS && image_target->voidp_sizeof == 8)
+	      info = ((grub_uint64_t) r->r_info << 32) |
+		      (grub_uint32_t) grub_be_to_cpu64 (r->r_info);
+	    else
+	      info = grub_target_to_host (r->r_info);
 
+	    sym_addr = SUFFIX (get_symbol_address) (e, symtab_section,
+						    ELF_R_SYM (info), image_target);
+	    addend = (s->sh_type == grub_target_to_host32 (SHT_RELA)) ?
+		grub_target_to_host (r->r_addend) : 0;
 	    addr = section_address + offset;
 
-	    translate_relocation (&ctx, addr, info, image_target);
+	    translate_relocation (&ctx, addr, info, sym_addr, addend, image_target);
 	  }
       }
 
diff --git a/util/grub-module-verifier.c b/util/grub-module-verifier.c
index 163529ca9..392363496 100644
--- a/util/grub-module-verifier.c
+++ b/util/grub-module-verifier.c
@@ -176,6 +176,32 @@ struct grub_module_verifier_arch archs[] = {
       -1
     }
   },
+  { "loongarch64", 8, 0, EM_LOONGARCH64, GRUB_MODULE_VERIFY_SUPPORTS_REL | GRUB_MODULE_VERIFY_SUPPORTS_RELA, (int[]){
+      R_LARCH_NONE,
+      R_LARCH_64,
+      R_LARCH_MARK_LA,
+      R_LARCH_SOP_PUSH_PCREL,
+      R_LARCH_SOP_PUSH_ABSOLUTE,
+      R_LARCH_SOP_PUSH_PLT_PCREL,
+      R_LARCH_SOP_SUB,
+      R_LARCH_SOP_SL,
+      R_LARCH_SOP_SR,
+      R_LARCH_SOP_ADD,
+      R_LARCH_SOP_AND,
+      R_LARCH_SOP_IF_ELSE,
+      R_LARCH_SOP_POP_32_S_10_5,
+      R_LARCH_SOP_POP_32_U_10_12,
+      R_LARCH_SOP_POP_32_S_10_12,
+      R_LARCH_SOP_POP_32_S_10_16,
+      R_LARCH_SOP_POP_32_S_10_16_S2,
+      R_LARCH_SOP_POP_32_S_5_20,
+      R_LARCH_SOP_POP_32_S_0_5_10_16_S2,
+      R_LARCH_SOP_POP_32_S_0_10_10_16_S2,
+      -1
+    }, (int[]){
+      -1
+    }
+  },
 };
 
 struct platform_whitelist {
diff --git a/util/mkimage.c b/util/mkimage.c
index a26cf76f7..841cb9965 100644
--- a/util/mkimage.c
+++ b/util/mkimage.c
@@ -654,6 +654,22 @@ static const struct grub_install_image_target_desc image_targets[] =
       .pe_target = GRUB_PE32_MACHINE_RISCV64,
       .elf_target = EM_RISCV,
     },
+    {
+      .dirname = "loongarch64-efi",
+      .names = { "loongarch64-efi", NULL },
+      .voidp_sizeof = 8,
+      .bigendian = 0,
+      .id = IMAGE_EFI,
+      .flags = PLATFORM_FLAGS_NONE,
+      .total_module_size = TARGET_NO_FIELD,
+      .decompressor_compressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_size = TARGET_NO_FIELD,
+      .decompressor_uncompressed_addr = TARGET_NO_FIELD,
+      .section_align = GRUB_PE32_SECTION_ALIGNMENT,
+      .vaddr_offset = EFI64_HEADER_SIZE,
+      .pe_target = GRUB_PE32_MACHINE_LOONGARCH64,
+      .elf_target = EM_LOONGARCH64,
+    },
   };
 
 #include <grub/lib/LzmaEnc.h>
-- 
2.33.0

